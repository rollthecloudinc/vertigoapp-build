{"version":3,"mappings":"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","names":["Subject","constructor","_value","super","this","value","getValue","_subscribe","subscriber","subscription","closed","next","hasError","thrownError","_throwIfClosed","ObjectUnsubscribedError","createErrorClass","_super","name","message","Observable","currentObservers","observers","isStopped","lift","operator","subject","AnonymousSubject","errorContext","Array","from","observer","error","err","length","shift","complete","unsubscribe","observed","_a","_trySubscribe","_checkFinalizedStatuses","_innerSubscribe","EMPTY_SUBSCRIPTION","push","Subscription","arrRemove","asObservable","observable","source","create","destination","_b","call","subscribe","args","scheduler","popScheduler","resultSelector","popResultSelector","observables","keys","argsArgArrayOrObject","result","valueTransform","identity","maybeSchedule","values","active","remainingFirstValues","i","hasFirstValue","createOperatorSubscriber","slice","combineLatestInit","createObject","pipe","mapOneOrManyArgs","execute","executeSchedule","mergeAll","concatAll","observableFactory","innerFrom","EMPTY","selector","operate","handledResult","innerSub","syncUnsub","undefined","catchError","project","isFunction","mergeMap","predicate","thisArg","index","callback","add","concurrent","Infinity","a","map","b","ii","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","v","bufferedValue","mergeInternals","concat","innerSubscriber","innerIndex","outerIndex","count","seen","observerOrNext","tapObserver","isUnsub","finalize","isArray","getPrototypeOf","prototype","objectProto","getKeys","Object","first","obj","isPOJO","key","reduce","fn","callOrApply"],"sources":["./node_modules/rxjs/dist/esm/internal/BehaviorSubject.js","./node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js","./node_modules/rxjs/dist/esm/internal/Subject.js","./node_modules/rxjs/dist/esm/internal/observable/combineLatest.js","./node_modules/rxjs/dist/esm/internal/observable/concat.js","./node_modules/rxjs/dist/esm/internal/operators/concatAll.js","./node_modules/rxjs/dist/esm/internal/observable/defer.js","./node_modules/rxjs/dist/esm/internal/observable/empty.js","./node_modules/rxjs/dist/esm/internal/operators/catchError.js","./node_modules/rxjs/dist/esm/internal/operators/concatMap.js","./node_modules/rxjs/dist/esm/internal/operators/filter.js","./node_modules/rxjs/dist/esm/internal/operators/finalize.js","./node_modules/rxjs/dist/esm/internal/operators/map.js","./node_modules/rxjs/dist/esm/internal/operators/mergeAll.js","./node_modules/rxjs/dist/esm/internal/operators/mergeMap.js","./node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js","./node_modules/rxjs/dist/esm/internal/operators/startWith.js","./node_modules/rxjs/dist/esm/internal/operators/switchMap.js","./node_modules/rxjs/dist/esm/internal/operators/take.js","./node_modules/rxjs/dist/esm/internal/operators/tap.js","./node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js","./node_modules/rxjs/dist/esm/internal/util/createObject.js","./node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js"],"sourcesContent":["import { Subject } from './Subject';\nexport class BehaviorSubject extends Subject {\n    constructor(_value) {\n        super();\n        this._value = _value;\n    }\n    get value() {\n        return this.getValue();\n    }\n    _subscribe(subscriber) {\n        const subscription = super._subscribe(subscriber);\n        !subscription.closed && subscriber.next(this._value);\n        return subscription;\n    }\n    getValue() {\n        const { hasError, thrownError, _value } = this;\n        if (hasError) {\n            throw thrownError;\n        }\n        this._throwIfClosed();\n        return _value;\n    }\n    next(value) {\n        super.next((this._value = value));\n    }\n}\n","import { createErrorClass } from './createErrorClass';\nexport const ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {\n    _super(this);\n    this.name = 'ObjectUnsubscribedError';\n    this.message = 'object unsubscribed';\n});\n","import { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nexport class Subject extends Observable {\n    constructor() {\n        super();\n        this.closed = false;\n        this.currentObservers = null;\n        this.observers = [];\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    lift(operator) {\n        const subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    }\n    _throwIfClosed() {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    }\n    next(value) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                if (!this.currentObservers) {\n                    this.currentObservers = Array.from(this.observers);\n                }\n                for (const observer of this.currentObservers) {\n                    observer.next(value);\n                }\n            }\n        });\n    }\n    error(err) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.hasError = this.isStopped = true;\n                this.thrownError = err;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    }\n    complete() {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.isStopped = true;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    }\n    unsubscribe() {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    }\n    get observed() {\n        var _a;\n        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n    }\n    _trySubscribe(subscriber) {\n        this._throwIfClosed();\n        return super._trySubscribe(subscriber);\n    }\n    _subscribe(subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    }\n    _innerSubscribe(subscriber) {\n        const { hasError, isStopped, observers } = this;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(() => {\n            this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    }\n    _checkFinalizedStatuses(subscriber) {\n        const { hasError, thrownError, isStopped } = this;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    }\n    asObservable() {\n        const observable = new Observable();\n        observable.source = this;\n        return observable;\n    }\n}\nSubject.create = (destination, source) => {\n    return new AnonymousSubject(destination, source);\n};\nexport class AnonymousSubject extends Subject {\n    constructor(destination, source) {\n        super();\n        this.destination = destination;\n        this.source = source;\n    }\n    next(value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    }\n    error(err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    }\n    complete() {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    _subscribe(subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    }\n}\n","import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function combineLatest(...args) {\n    const scheduler = popScheduler(args);\n    const resultSelector = popResultSelector(args);\n    const { args: observables, keys } = argsArgArrayOrObject(args);\n    if (observables.length === 0) {\n        return from([], scheduler);\n    }\n    const result = new Observable(combineLatestInit(observables, scheduler, keys\n        ?\n            (values) => createObject(keys, values)\n        :\n            identity));\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nexport function combineLatestInit(observables, scheduler, valueTransform = identity) {\n    return (subscriber) => {\n        maybeSchedule(scheduler, () => {\n            const { length } = observables;\n            const values = new Array(length);\n            let active = length;\n            let remainingFirstValues = length;\n            for (let i = 0; i < length; i++) {\n                maybeSchedule(scheduler, () => {\n                    const source = from(observables[i], scheduler);\n                    let hasFirstValue = false;\n                    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                        values[i] = value;\n                        if (!hasFirstValue) {\n                            hasFirstValue = true;\n                            remainingFirstValues--;\n                        }\n                        if (!remainingFirstValues) {\n                            subscriber.next(valueTransform(values.slice()));\n                        }\n                    }, () => {\n                        if (!--active) {\n                            subscriber.complete();\n                        }\n                    }));\n                }, subscriber);\n            }\n        }, subscriber);\n    };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n    if (scheduler) {\n        executeSchedule(subscription, scheduler, execute);\n    }\n    else {\n        execute();\n    }\n}\n","import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat(...args) {\n    return concatAll()(from(args, popScheduler(args)));\n}\n","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nexport function defer(observableFactory) {\n    return new Observable((subscriber) => {\n        innerFrom(observableFactory()).subscribe(subscriber);\n    });\n}\n","import { Observable } from '../Observable';\nexport const EMPTY = new Observable((subscriber) => subscriber.complete());\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\nexport function catchError(selector) {\n    return operate((source, subscriber) => {\n        let innerSub = null;\n        let syncUnsub = false;\n        let handledResult;\n        innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n            handledResult = innerFrom(selector(err, catchError(selector)(source)));\n            if (innerSub) {\n                innerSub.unsubscribe();\n                innerSub = null;\n                handledResult.subscribe(subscriber);\n            }\n            else {\n                syncUnsub = true;\n            }\n        }));\n        if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            handledResult.subscribe(subscriber);\n        }\n    });\n}\n","import { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\nexport function concatMap(project, resultSelector) {\n    return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n","import { operate } from '../util/lift';\nexport function finalize(callback) {\n    return operate((source, subscriber) => {\n        try {\n            source.subscribe(subscriber);\n        }\n        finally {\n            subscriber.add(callback);\n        }\n    });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent = Infinity) {\n    return mergeMap(identity, concurrent);\n}\n","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent = Infinity) {\n    if (isFunction(resultSelector)) {\n        return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    const buffer = [];\n    let active = 0;\n    let index = 0;\n    let isComplete = false;\n    const checkComplete = () => {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n    const doInnerSub = (value) => {\n        expand && subscriber.next(value);\n        active++;\n        let innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, () => {\n            innerComplete = true;\n        }, undefined, () => {\n            if (innerComplete) {\n                try {\n                    active--;\n                    while (buffer.length && active < concurrent) {\n                        const bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {\n        isComplete = true;\n        checkComplete();\n    }));\n    return () => {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith(...values) {\n    const scheduler = popScheduler(values);\n    return operate((source, subscriber) => {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate((source, subscriber) => {\n        let innerSubscriber = null;\n        let index = 0;\n        let isComplete = false;\n        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            let innerIndex = 0;\n            const outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, () => {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function take(count) {\n    return count <= 0\n        ?\n            () => EMPTY\n        : operate((source, subscriber) => {\n            let seen = 0;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\n","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    const tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error, complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate((source, subscriber) => {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            let isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, () => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, (err) => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, () => {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n","const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\nexport function argsArgArrayOrObject(args) {\n    if (args.length === 1) {\n        const first = args[0];\n        if (isArray(first)) {\n            return { args: first, keys: null };\n        }\n        if (isPOJO(first)) {\n            const keys = getKeys(first);\n            return {\n                args: keys.map((key) => first[key]),\n                keys,\n            };\n        }\n    }\n    return { args: args, keys: null };\n}\nfunction isPOJO(obj) {\n    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n","export function createObject(keys, values) {\n    return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {});\n}\n","import { map } from \"../operators/map\";\nconst { isArray } = Array;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn(...args) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(args => callOrApply(fn, args));\n}\n"],"sourceRoot":"webpack:///","file":"527.b8aee97cafa8935b.js"}