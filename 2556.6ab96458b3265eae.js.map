{"version":3,"file":"2556.6ab96458b3265eae.js","mappings":"uIAGO,SAASA,IAAgB,QAAAC,EAAAC,UAAAC,OAANC,EAAI,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GAC1B,OCHG,SAASC,IACZ,SAAOC,KAAS,EACpB,CDCWD,IAAS,EAAGE,KAAKL,KAAMM,MAAaN,IAC/C,8DEHO,SAASO,EAAMC,GAClB,OAAO,IAAIC,IAAW,SAACC,IACnBC,QAAUH,KAAqBI,UAAUF,EAC7C,EACJ,wCCLaG,EAAQ,aAAIJ,GAAW,SAACC,GAAU,OAAKA,EAAWI,UAAU,sHCKnEC,EAA0B,CAAC,cAAe,kBAC1CC,EAAqB,CAAC,mBAAoB,uBAC1CC,EAAgB,CAAC,KAAM,OACtB,SAASC,EAAUC,EAAQC,EAAWC,EAASC,GAKlD,MAJIC,KAAWF,KACXC,EAAiBD,EACjBA,OAAUG,GAEVF,EACA,OAAOJ,EAAUC,EAAQC,EAAWC,GAASI,QAAKC,KAAiBJ,IAEvE,IAAAK,EA+BJ,SAASC,EAAcT,GACnB,SAAOI,KAAWJ,EAAOU,oBAAgB,EAAKN,KAAWJ,EAAOW,oBACpE,CAjC0BF,CAAcT,GAC9BH,EAAmBe,IAAI,SAACC,GAAU,OAAK,SAACC,GAAO,OAAKd,EAAOa,GAAYZ,EAAWa,EAASZ,EAAQ,IAwB7G,SAASa,EAAwBf,GAC7B,SAAOI,KAAWJ,EAAOgB,eAAW,EAAKZ,KAAWJ,EAAOiB,eAC/D,CAxBYF,CAAwBf,GAClBJ,EAAwBgB,IAAIM,EAAwBlB,EAAQC,IAwB9E,SAASkB,EAA0BnB,GAC/B,SAAOI,KAAWJ,EAAOoB,MAAE,EAAKhB,KAAWJ,EAAOqB,IACtD,CAzBkBF,CAA0BnB,GACtBF,EAAcc,IAAIM,EAAwBlB,EAAQC,IAClD,GAAEqB,KAAAC,KAAAf,EAAA,GAPbgB,EAAGF,EAAA,GAAEG,EAAMH,EAAA,GAQlB,IAAKE,MACGE,KAAY1B,GACZ,SAAO2B,KAAS,SAACC,GAAS,OAAK7B,EAAU6B,EAAW3B,EAAWC,EAAQ,EAAvE,EAAuE,EAAEV,MAAUQ,IAG3F,IAAKwB,EACD,MAAM,IAAIK,UAAU,wBAExB,OAAO,IAAIvC,IAAW,SAACC,GACnB,IAAMuB,EAAU,WAAH,QAAApC,EAAAC,UAAAC,OAAOC,EAAI,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GAAA,OAAKQ,EAAWuC,KAAK,EAAIjD,EAAKD,OAASC,EAAOA,EAAK,GAAG,EAC9E2C,SAAIV,GACG,kBAAMW,EAAOX,EAAQ,CAChC,EACJ,CACA,SAASI,EAAwBlB,EAAQC,GACrC,OAAO,SAACY,GAAU,OAAK,SAACC,GAAO,OAAKd,EAAOa,GAAYZ,EAAWa,EAAQ,EAC9E,8FCpCO,SAASiB,IAAe,QAAArD,EAAAC,UAAAC,OAANC,EAAI,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GACzB,IAAMiD,KAAY7C,MAAaN,GACzBoD,KAAaC,MAAUrD,EAAMsD,KAC7BC,EAAUvD,EAChB,OAAQuD,EAAQxD,OAGS,IAAnBwD,EAAQxD,QAAW,EAEbY,MAAU4C,EAAQ,KAAE,EAEpBnD,KAASgD,EAFW,EAED,EAAE/C,KAAKkD,EAASJ,IALvCtC,GAMZ,+DCfO,SAAS2C,IAAY,QAAA3D,EAAAC,UAAAC,OAANC,EAAI,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GACtB,IAAMiD,KAAY7C,MAAaN,GAC/B,SAAOK,KAAKL,EAAMmD,EACtB,uGCAO,SAASM,EAAUC,EAAuBC,GAC7C,OAAIA,EACO,SAACC,GAAM,SAAKhE,KAAO+D,EAAkBlC,QAAKoC,KAAK,IAAC,EAAGC,QAAmBF,EAAOnC,KAAKgC,EAAUC,IAAwB,KAExHZ,KAAS,SAACiB,EAAOC,GAAK,OAAKN,EAAsBK,EAAOC,GAAOvC,QAAKoC,KAAK,IAAC,EAAGI,KAAMF,GAAO,EACrG,gBCPO,SAASG,EAAMC,GAAiC,IAC7CC,KAAWC,KAAMF,EADSrE,UAAAC,OAAA,QAAAyB,IAAA1B,UAAA,GAAAA,UAAA,GAAGwE,KAEnC,OAAOb,EAAU,kBAAMW,CAAQ,EACnC,8DCJO,SAASG,EAAOC,EAAWC,GAC9B,SAAOC,KAAQ,SAACd,EAAQlD,GACpB,IAAIsD,EAAQ,EACZJ,EAAOhD,aAAU+D,KAAyBjE,EAAY,SAACqD,GAAK,OAAKS,EAAUI,KAAKH,EAASV,EAAOC,MAAYtD,EAAWuC,KAAKc,EAAM,GACtI,EACJ,yECJO,SAASD,IACZ,SAAOY,KAAQ,SAACd,EAAQlD,GACpBkD,EAAOhD,aAAU+D,KAAyBjE,EAAYmE,KAC1D,EACJ,gDCNO,SAASZ,EAAMF,GAClB,SAAOhC,KAAI,kBAAMgC,CAAK,EAC1B,6DCDO,SAAS3D,IACZ,SAAO0C,KAASgC,IADehF,UAAAC,OAAA,QAAAyB,IAAA1B,UAAA,GAAAA,UAAA,GAAGwD,IAEtC,yECDO,SAASyB,IAAqB,QAAAlF,EAAAC,UAAAC,OAARiF,EAAM,IAAA/E,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAN8E,EAAM9E,GAAAJ,UAAAI,GAC/B,IAAMiD,KAAY7C,MAAa0E,GAC/B,SAAON,KAAQ,SAACd,EAAQlD,IACnByC,KAAYvD,KAAOoF,EAAQpB,EAAQT,IAAS,EAAIvD,KAAOoF,EAAQpB,IAAShD,UAAUF,EACvF,EACJ,yECLO,SAASuE,EAAUC,EAAS5D,GAC/B,SAAOoD,KAAQ,SAACd,EAAQlD,GACpB,IAAIyE,EAAkB,KAClBnB,EAAQ,EACRoB,GAAa,EACXC,EAAgB,WAAH,OAASD,IAAeD,GAAmBzE,EAAWI,UAAU,EACnF8C,EAAOhD,aAAU+D,KAAyBjE,EAAY,SAACqD,GACeoB,GAAgBG,cAClF,IAAIC,EAAa,EACXC,EAAaxB,KACnBrD,QAAUuE,EAAQnB,EAAOyB,IAAa5E,UAAWuE,KAAkBR,KAAyBjE,EAAY,SAAC+E,GAAU,OAAK/E,EAAWuC,KAAK3B,EAAiBA,EAAeyC,EAAO0B,EAAYD,EAAYD,KAAgBE,EAAW,EAAE,WAChON,EAAkB,KAClBE,GACJ,GACJ,EAAG,WACCD,GAAa,EACbC,GACJ,GACJ,EACJ,yECnBO,SAASxB,EAAK6B,GACjB,OAAOA,GAAS,EAER,kBAAM7E,GAAK,KACb6D,KAAQ,SAACd,EAAQlD,GACf,IAAIiF,EAAO,EACX/B,EAAOhD,aAAU+D,KAAyBjE,EAAY,SAACqD,KAC7C4B,GAAQD,IACVhF,EAAWuC,KAAKc,GACZ2B,GAASC,GACTjF,EAAWI,WAGvB,GACJ,EACR,oFCdO,SAAS8E,EAAIC,EAAgBC,EAAOhF,GACvC,IAAMiF,KAAcxE,KAAWsE,IAAmBC,GAAShF,EAEnD,CAAEmC,KAAM4C,EAAgBC,QAAOhF,YACjC+E,EACN,OAAOE,KACDrB,KAAQ,SAACd,EAAQlD,GACf,IAAIsF,EAC6B,QAAhCA,EAAKD,EAAYnF,iBAA8B,IAAPoF,GAAyBA,EAAGpB,KAAKmB,GAC1E,IAAIE,GAAU,EACdrC,EAAOhD,aAAU+D,KAAyBjE,EAAY,SAACqD,GACnD,IAAIiC,EACwB,QAA3BA,EAAKD,EAAY9C,YAAyB,IAAP+C,GAAyBA,EAAGpB,KAAKmB,EAAahC,GAClFrD,EAAWuC,KAAKc,EACpB,EAAG,WACC,IAAIiC,EACJC,GAAU,EACsB,QAA/BD,EAAKD,EAAYjF,gBAA6B,IAAPkF,GAAyBA,EAAGpB,KAAKmB,GACzErF,EAAWI,UACf,EAAG,SAACoF,GACA,IAAIF,EACJC,GAAU,EACmB,QAA5BD,EAAKD,EAAYD,aAA0B,IAAPE,GAAyBA,EAAGpB,KAAKmB,EAAaG,GACnFxF,EAAWoF,MAAMI,EACrB,EAAG,WACC,IAAIF,EAAIG,EACJF,IACmC,QAAlCD,EAAKD,EAAYT,mBAAgC,IAAPU,GAAyBA,EAAGpB,KAAKmB,IAEhD,QAA/BI,EAAKJ,EAAYK,gBAA6B,IAAPD,GAAyBA,EAAGvB,KAAKmB,EAC7E,GACJ,GAEIjB,GACZ,q7BCbAuB,GAAA,mBAAAC,GAAAC,EAAAC,GA2Q2jC,GA3Q3jC,EAAAD,IA0LoGE,2BAAE,aAAFA,yBAAE,GAAFA,4BAiFu9B,EAAAF,EAAA,KAAAG,EAAAF,EAAAG,GAAAC,EAjFv9BH,mDAAE,KAAAG,EAAAD,GAAFF,CAiFwtB,UAAAG,EAAAC,WAjFxtBJ,CAiFwtB,kBAAAG,EAAAE,OAAA,oBAjFxtBL,wBAAE,aAAAG,EAAAG,WAAA,KAAFN,CAiFmyB,kBAAAG,EAAAI,wBAAAN,GAAA,MAAAO,GAAA,MA1Qj4BC,IAAiBC,QAAQ,iBAAkB,EAC7CC,QAAM,gBAAgBC,QAAM,CACxBC,QAAS,EACTC,UAAW,kBAEfC,QAAW,4BAA6B,EACpCC,QAAM,EACFC,QAAQ,gBAAgBL,QAAM,CAAEC,QAAS,MACzCI,QAAQ,oCAAoCL,QAAM,CAAEE,UAAW,oBAGvEC,QAAW,4BAA6B,EAACE,QAAQ,iBAAiBL,QAAM,CAAEC,QAAS,SAOnFK,GAA+B,EAE7BC,GAA4BC,OAC9B,SAAAD,EAEAhE,EAEAkE,IAAQC,OAAAC,KAAAJ,GACJI,KAAKpE,OAASA,EACdoE,KAAKF,OAASA,CAClB,GAIEG,IAA4BC,wBAAkB,oBAAAL,KAAA,SAAAM,KAAAJ,OAAAC,KAAAG,EAAA,OAG9CC,EAAmC,IAAIC,iBAAe,mCAAoC,CAC5FC,WAAY,OACZC,QAASC,IAGb,SAASA,IACL,MAAO,CACHC,uBAAuB,EACvBC,wBAAwB,EACxBC,8BAA8B,EAEtC,CACA,IACMC,EAAoB,eAApBA,EAAoB,SAAAC,IAAAC,OAAAF,EAAAC,GAAA,IAAAE,KAAAC,KAAAJ,GA6CtB,SAAAA,EAAYK,EAAoBC,EAAaC,EAAWC,GAAU,IAAAC,EAAAtB,cAAAC,KAAAY,IAC9DS,EAAAN,EAAAnE,KAAAoD,OACKiB,mBAAqBA,EAC1BI,EAAKH,YAAcA,EACnBG,EAAKF,UAAYA,EACjBE,EAAKC,qBAAuBC,WAE5BF,EAAKG,WAAY,EACjBH,EAAKI,SAAU,EAEfJ,EAAKK,YAAc,KAEnBL,EAAKM,eAAiB,IAAIC,eAE1BP,EAAKQ,OAAS,IAAID,eAElBP,EAAKS,OAAS,IAAIF,eAElBP,EAAKU,gBAAkB,IAAIH,eAC3BP,EAAKxC,WAAa,CAAC,EAEnBwC,EAAK1C,GAAE,oBAAA/G,OAAuB+H,MAK9B0B,EAAKW,YAAcZ,GAAUa,SAAU,EACvCZ,EAAKa,yBAA2Bf,EAAUV,sBAC1CY,EAAKc,0BAA4BhB,EAAUT,uBAAuBW,CACtE,CAACxB,cAAAe,EAAA,EAAAwB,IAAA,SAAAC,eAvEG,OAAOrC,KAAKyB,SAAWzB,KAAKwB,SAChC,GACA,CAAAY,IAAA,YAAArG,MACA,SAAUA,GACNiE,KAAKsC,OAASvG,EACdiE,KAAKuC,iBAAiBvC,KAAKnB,WAC/B,GACA,CAAAuD,IAAA,wBAAAC,IAIA,WACI,OAAOrC,KAAKkC,sBAChB,EAACM,IACD,SAA0BzG,GACtBiE,KAAKkC,0BAAyBO,yBAAsB1G,EACxD,GACA,CAAAqG,IAAA,yBAAAC,IACA,WACI,OAAOrC,KAAKmC,uBAChB,EAACK,IACD,SAA2BzG,GACvBiE,KAAKmC,2BAA0BM,yBAAsB1G,EACzD,GACA,CAAAqG,IAAA,YAAAI,IAIA,SAAczG,GAENiE,KAAKnB,WADL9C,GAASA,EAAMhE,QACV8G,EAAa6D,qBAAkB3G,GAAO4G,OAAO,SAACC,EAAWC,GAC1DD,SAAUC,IAAa,EAChBD,CACX,EAAG,CAAC,GAGc,CAAC,EAEvB5C,KAAK8C,sBAAsB9C,KAAKnB,YAChCmB,KAAKuC,iBAAiBvC,KAAKnB,YAC3BmB,KAAKkB,YAAY6B,cAAcF,UAAY,EAC/C,GAAC,CAAAT,IAAA,qBAAArG,MA+BD,WAAqB,IAAAiH,EAAAhD,KACjBA,KAAKiD,YAAc,IAAIC,6BAA2BlD,KAAK3G,SAClD8J,WACAC,cAAcpD,KAAKqD,gBACxBrD,KAAKsB,qBAAuBtB,KAAKiD,YAAYK,OAAO1K,UAAU,SAAAoD,GACtDgH,EAAKlE,QACLkE,EAAKjB,gBAAgBwB,KAAK,CAAE3H,OAAQoH,EAAMlD,OAAQkD,EAAK3J,QAAQmK,UAAUxH,IAAU,MAE3F,GAEAgE,KAAKyD,gBACT,GAAC,CAAArB,IAAA,cAAArG,MACD,WAAc,IAAA2H,EACM,QAAhBA,EAAA1D,KAAKiD,mBAAW,IAAAS,GAAhBA,EAAkBC,UAClB3D,KAAKsB,qBAAqBhE,aAC9B,GACA,CAAA8E,IAAA,gBAAArG,MAIA,SAAc6H,GACN5D,KAAK6D,QACL7D,KAAK6D,MAAMd,cAAca,UAAYA,EAE7C,GACA,CAAAxB,IAAA,gBAAArG,MACA,WACI,OAAOiE,KAAK6D,MAAQ7D,KAAK6D,MAAMd,cAAca,UAAY,CAC7D,GACA,CAAAxB,IAAA,iBAAArG,MACA,WACIiE,KAAKwB,YAAcxB,KAAK3G,QAAQtB,OAChCiI,KAAK8C,sBAAsB9C,KAAKnB,YAChCmB,KAAKiB,mBAAmB6C,cAC5B,GACA,CAAA1B,IAAA,mBAAArG,MACA,SAAiB+D,GACb,IAAMiE,EAAQ,IAAInE,EAA6BI,KAAMF,GACrDE,KAAK2B,eAAe4B,KAAKQ,EAC7B,GACA,CAAA3B,IAAA,0BAAArG,MACA,SAAwBiI,GACpB,OAAIhE,KAAKjB,UACE,KAGJiB,KAAKiE,gBADYD,EAAUA,EAAU,IAAM,IACHhE,KAAKiE,eAAiBD,CACzE,GACA,CAAA5B,IAAA,wBAAArG,MACA,SAAsB6G,GAClBA,EAAU5C,KAAKkE,eAAiBlE,KAAKwB,UACrCoB,EAAU5C,KAAKmE,eAAiBnE,KAAKwB,SACzC,GACA,CAAAY,IAAA,mBAAArG,MACA,SAAiB6G,GACbA,EAAU,eAAiC,YAAhB5C,KAAKsC,OAChCM,EAAU,YAA8B,SAAhB5C,KAAKsC,OAC7BM,EAAU,cAAgC,WAAhB5C,KAAKsC,MACnC,GAAC,CAAAF,IAAA,iBAAArG,MACD,SAAe+D,GACX,OAAOA,EAAOsE,QAClB,KAACxD,CAAA,CAxIqB,CAASX,IAA7BW,SAyIYyD,UAAI,SAAAC,GAAA,WAAAA,GAAwF1D,GAAVnC,8BAAgDA,qBAAhDA,8BAAiFA,cAAjFA,8BAA2G2B,GAA3G3B,8BAAwJ8F,YAAW,EAzIjQ3D,EA0IY4D,UADkF/F,8BAAE,CAAAgG,KACJ7D,EAAoB8D,UAAA,SAAAnG,EAAAC,GADhB,IAAAmG,EACgB,EAAApG,IADlBE,wBACmfmG,cAAW,GAD9fnG,wBAAEJ,GAAA,MAAAE,IAAFE,2BAAEkG,EAAFlG,6BAAED,EAAAqG,SAAAF,EAAAG,OAAFrG,2BAAEkG,EAAFlG,6BAAED,EAAAqF,MAAAc,EAAAG,OAAA,EAAAC,OAAA,CAAAhG,UAAA,2BAAAkF,eAAA,qCAAAvC,YAAA,cAAAjB,sBAAA,wBAAAC,uBAAA,yBAAAsE,WAAA,aAAApC,UAAA,uBAAAqC,QAAA,CAAAtD,eAAA,iBAAAE,OAAA,SAAAC,OAAA,SAAAC,gBAAA,mBAAAmD,SAAA,CAAFzG,0CAzI9FmC,CAAoB,IAiLpBuE,GAAe,eAAfA,EAAe,SAAAC,IAAAtE,OAAAqE,EAAAC,GAAA,IAAAC,KAAArE,KAAAmE,GACjB,SAAAA,IAAc,IAAAG,EAAAC,EAAAxF,cAAAC,KAAAmF,IACVI,EAAAF,EAAAG,MAAAxF,KAASlI,YACJoM,cAAgB,+BACrBqB,EAAKpB,aAAe,8BACpBoB,EAAKE,8BAA2E,QAA9CH,EAAGC,EAAKpE,UAAUR,oCAA4B,IAAA2E,KAAUC,CAC9F,CACA1F,cAAAsF,EAAA,EAAA/C,IAAA,+BAAAC,IACA,WACI,OAAOrC,KAAKyF,6BAChB,EAACjD,IACD,SAAiCzG,GAC7BiE,KAAKyF,iCAAgChD,yBAAsB1G,GAC3DiE,KAAK0F,uBACT,GACA,CAAAtD,IAAA,wBAAArG,MACA,WACI,GAAIiE,KAAK3G,QAAS,KACmBsM,EADnBC,KAAAC,KACO7F,KAAK3G,SAAO,IAAjC,IAAAuM,EAAAE,MAAAH,EAAAC,EAAAG,KAAAC,MAAiBL,EAAA5J,MACNkF,mBAAmB6C,cAC7B,OAAA5F,GAAA0H,EAAAK,EAAA/H,EAAA,SAAA0H,EAAAM,GAAA,EAET,GAcA,CAAA9D,IAAA,iBAAArG,MACA,SAAeoK,GACX,OAAO,CACX,KAAChB,CAAA,CAvCgB,CAASvE,GAAxBuE,SAwCYd,UAAI,eAAA+B,EAAA,gBAAA9B,GAAA,OAAA8B,MAhF8E3H,kCAgFU0G,KAAeb,GAAfa,EAAe,EAAvG,GAxChBA,EAyCYkB,UAjFkF5H,8BAAE,CAAAgG,KAiFJU,EAAemB,UAAA,uBAAAC,eAAA,SAAAhI,EAAAC,EAAAgI,GAA+b,IAAA7B,EAA/b,EAAApG,IAjFbE,2BAAE+H,EAiFwXC,eAAY,GAjFtYhI,2BAAE+H,EAiFicE,YAAS,MAAAnI,IAjF5cE,2BAAEkG,EAAFlG,6BAAED,EAAAmI,aAAAhC,GAAFlG,2BAAEkG,EAAFlG,6BAAED,EAAAnF,QAAAsL,GAAA,EAAAiC,UAAA,mBAiF8L,GAAE,0BAAA7B,OAAA,CAAA8B,cAAA,gBAAAlG,6BAAA,gCAAAmG,SAAA,oBAAA5B,SAAA,CAjFlMzG,+BAiF2P,CAAC,CAAEsI,QAASC,8BAA6BC,YAAa9B,KAjFjT1G,wCAAEyI,mBAAAjI,GAAAkI,MAAA,EAAAC,KAAA,EAAAC,OAAA,8HAAAxC,SAAA,SAAAtG,EAAAC,GAAA,EAAAD,IAAFE,qDAAE,EAAAH,GAAA,mBAiFq+B,EAAAgJ,aAAA,CAA86DC,WAAUC,OAAA,s3DAAAC,cAAA,EAAAC,KAAA,CAAAC,UAAsE,CAACzI,KAAe0I,gBAAA,IAzCnlGzC,CAAe,IA4Df0C,EAA0B,eAA1BA,GAA0BhI,OAC5B,SAAAgI,EAEAC,IAAY/H,OAAAC,KAAA6H,GACR7H,KAAK8H,WAAaA,CACtB,GALED,SAMYxD,UAAI,SAAAC,GAAA,WAAAA,GAAwFuD,GA1GVpJ,8BA0GsDA,cAAa,EANjKoJ,EAOYrD,UA3GkF/F,8BAAE,CAAAgG,KA2GJoD,IAP5FA,CAA0B,IAgB1BE,GAAqB,eAArBA,EAAqB,SAAAC,IAAAlH,OAAAiH,EAAAC,GAAA,IAAAC,KAAAjH,KAAA+G,GAAA,SAAAA,IAAAhI,cAAAC,KAAA+H,GAAAE,EAAAzC,MAAAxF,KAAAlI,UAAA,UAAA+H,KAAAkI,EAAA,EAASF,GAA9BE,SACY1D,UAAI,eAAA6D,EAAA,gBAAA5D,GAAA,OAAA4D,MArH8EzJ,kCAqHUsJ,KAAqBzD,GAArByD,EAAqB,EAA7G,GADhBA,EAEYvD,UAtHkF/F,8BAAE,CAAAgG,KAsHJsD,EAAqBzB,UAAA,kCAAAQ,SAAA,0BAAA5B,SAAA,CAtHnBzG,0CAoH9FsJ,CAAqB,IAgBrBI,EAAkC,CACpCpB,QAASqB,KACTnB,aAAaoB,gBAAW,kBAAMC,CAAsB,GACpDC,OAAO,GAMX,SAASC,KACL,OAAOC,MAAM,4MAGjB,CAEA,IAAMC,EAAmC,IAAIrI,iBAAe,oCAE5D,SAASsI,EAAyCC,GAC9C,OAAO,kBAAMA,EAAQC,iBAAiBC,YAAY,CACtD,CAEA,IAAMC,EAAoD,CACtDhC,QAAS2B,EACTM,KAAM,CAACC,WACPC,WAAYP,GAGVQ,EAA2B,eAA3BA,EAA2B,WAW7B,SAAAA,EAAYC,EAAUC,EAAUC,EAAmBC,EAAOtI,EAAoBuI,EAAgBC,EAAMC,GAAYC,GAAWC,GAAgBzI,IAAW,IAAA0I,EAAA7J,MAAAD,OAAAC,KAAAmJ,GAClJnJ,KAAKoJ,SAAWA,EAChBpJ,KAAKqJ,SAAWA,EAChBrJ,KAAKsJ,kBAAoBA,EACzBtJ,KAAKuJ,MAAQA,EACbvJ,KAAKiB,mBAAqBA,EAC1BjB,KAAKyJ,KAAOA,EACZzJ,KAAK0J,WAAaA,GAClB1J,KAAK2J,UAAYA,GACjB3J,KAAK4J,eAAiBA,GACtB5J,KAAKmB,UAAYA,GACjBnB,KAAK8J,qBAAsB,EAC3B9J,KAAK+J,uBAAwB,EAE7B/J,KAAKgK,wBAAyB,EAE9BhK,KAAKiK,sBAAwB1I,WAM7BvB,KAAKkK,qBAAsB,EAE3BlK,KAAKmK,qBAAuB,IAAIC,IAKhCpK,KAAKqK,mBAAqB,WAItBR,EAAKK,oBACDL,EAAKF,UAAUW,gBAAkBT,EAAKT,SAASrG,eAAiB8G,EAAKU,SAC7E,EAEAvK,KAAKwK,UAAY,WAAQ,EAEzBxK,KAAKyK,WAAa,WAAQ,EAQ1BzK,KAAK0K,SAAW,OAKhB1K,KAAK2K,sBAAwB,MAC7B3K,KAAK4K,kBAAmB,EAExB5K,KAAK6K,oBAAmBtS,KAAM,WAC1B,IAAMc,EAAUwQ,EAAKiB,aAAejB,EAAKiB,aAAazR,QAAU,KAChE,OAAIA,EACOA,EAAQ0R,QAAQtR,QAAKsD,KAAU1D,IAAO,EAAG4D,KAAU,kBAAM/B,eAAK,KAAA8P,KAAI3R,EAAQU,IAAI,SAAA+F,IAAM,OAAIA,GAAOmL,iBAAiB,IAAE,IAItHpB,EAAKN,MAAM2B,SAASzR,QAAKoC,KAAK,IAAC,EAAGoB,KAAU,kBAAM4M,EAAKgB,gBAAgB,GAClF,GACA7K,KAAKmL,gBAAkB3B,CAC3B,CAAC3J,cAAAsJ,EAAA,EAAA/G,IAAA,uBAAAC,eAtEG,OAAOrC,KAAK+J,qBAChB,EAACvH,IACD,SAAyBzG,GACrBiE,KAAK+J,yBAAwBtH,yBAAsB1G,EACvD,GAAC,CAAAqG,IAAA,kBAAArG,MAmED,WAAkB,IAAAqP,EAAApL,KACRqL,EAASrL,KAAKsL,oBACTD,EAAW,KAClBrL,KAAKuJ,MAAMgC,kBAAkB,kBAAMF,EAAOxR,iBAAiB,OAAQuR,EAAKf,mBAAmB,EAEnG,GAAC,CAAAjI,IAAA,cAAArG,MACD,SAAYgP,GACJA,EAAQL,UAAe1K,KAAKwL,oBAC5BxL,KAAKyL,sBAAsBzL,KAAKwL,mBAC5BxL,KAAKuK,WACLvK,KAAK0L,YAAYC,iBAG7B,GAAC,CAAAvJ,IAAA,cAAArG,MACD,WACI,IAAMsP,EAASrL,KAAKsL,oBACTD,EAAW,KAClBA,EAAOvR,oBAAoB,OAAQkG,KAAKqK,oBAE5CrK,KAAKiK,sBAAsB3M,cAC3B0C,KAAK8J,qBAAsB,EAC3B9J,KAAK4L,gBACL5L,KAAKmK,qBAAqBrR,UAC9B,GACA,CAAAsJ,IAAA,YAAAC,IACA,WACI,OAAOrC,KAAK4K,kBAAoB5K,KAAK8K,aAAatJ,SACtD,GACA,CAAAY,IAAA,YAAArG,MACA,WACIiE,KAAK6L,iBACL7L,KAAK8L,aACT,GACA,CAAA1J,IAAA,aAAArG,MACA,WAAa,IAAAgQ,EAAA/L,KACTA,KAAKgM,cACAhM,KAAK4K,mBAGN5K,KAAKuK,WAKLvK,KAAKuJ,MAAM0C,IAAI,WACXF,EAAKjB,aAAahJ,OAAOyB,MAC7B,GAEJvD,KAAK8K,aAAarJ,QAAUzB,KAAK4K,kBAAmB,EACpD5K,KAAKkM,2BAA6B,KAC9BlM,KAAK0L,aAAe1L,KAAK0L,YAAYS,gBACrCnM,KAAK0L,YAAYU,SACjBpM,KAAKqM,4BAA4B/O,eAIhC0C,KAAK8J,qBAKN9J,KAAKiB,mBAAmBqL,gBAEhC,GACA,CAAAlK,IAAA,iBAAArG,MAIA,WACQiE,KAAK4K,kBACL5K,KAAK0L,YAAYC,gBAEzB,GACA,CAAAvJ,IAAA,sBAAAC,IAIA,WAA0B,IAAAkK,EAAAvM,KACtB,SAAO9E,KAAM8E,KAAK6K,iBAAkB7K,KAAK8K,aAAa7H,YAAYuJ,OAAO/S,QAAK8C,KAAO,kBAAMgQ,EAAK3B,gBAAgB,IAAI5K,KAAKmK,qBAAsBnK,KAAKyM,yBAA0BzM,KAAK0L,YAC7K1L,KAAK0L,YAAYgB,cAAcjT,QAAK8C,KAAO,kBAAMgQ,EAAK3B,gBAAgB,KAAC,EACvEpP,SAAM/B,QAEZM,MAAI,SAAAgK,GAAK,OAAKA,aAAiB4I,2BAA2B5I,EAAQ,IAAI,GAC1E,GACA,CAAA3B,IAAA,eAAAC,IACA,WACI,OAAIrC,KAAK8K,cAAgB9K,KAAK8K,aAAa7H,YAChCjD,KAAK8K,aAAa7H,YAAY2J,WAElC,IACX,GACA,CAAAxK,IAAA,yBAAArG,MACA,WAAyB,IAAA8Q,EAAA7M,KACrB,SAAO9E,QAAMhC,KAAU8G,KAAK2J,UAAW,UAAO,EAAGzQ,KAAU8G,KAAK2J,UAAW,aAAU,EAAGzQ,KAAU8G,KAAK2J,UAAW,aAAalQ,QAAK8C,KAAO,SAAAwH,GAGvI,IAAM+I,KAAcC,mBAAgBhJ,GAC9BiJ,EAAYH,EAAKnD,WAAamD,EAAKnD,WAAWxI,YAAY6B,cAAgB,KAC1EkK,EAAeJ,EAAKK,YAAcL,EAAKK,YAAYpF,WAAW/E,cAAgB,KACpF,OAAQ8J,EAAKjC,kBACTkC,IAAgBD,EAAKzD,SAASrG,eAK9B8J,EAAKlD,UAAUW,gBAAkBuC,EAAKzD,SAASrG,iBAC7CiK,IAAcA,EAAUG,SAASL,OACjCG,IAAiBA,EAAaE,SAASL,OACvCD,EAAKnB,cACNmB,EAAKnB,YAAY0B,eAAeD,SAASL,EAClD,GACJ,GACA,CAAA1K,IAAA,aAAArG,MACA,SAAWA,GAAO,IAAAsR,EAAArN,KACdsN,QAAQC,QAAQ,MAAMC,KAAK,kBAAMH,EAAKI,mBAAmB1R,EAAM,EACnE,GACA,CAAAqG,IAAA,mBAAArG,MACA,SAAiB2R,GACb1N,KAAKwK,UAAYkD,CACrB,GACA,CAAAtL,IAAA,oBAAArG,MACA,SAAkB2R,GACd1N,KAAKyK,WAAaiD,CACtB,GACA,CAAAtL,IAAA,mBAAArG,MACA,SAAiB4R,GACb3N,KAAKoJ,SAASrG,cAAcqB,SAAWuJ,CAC3C,GAAC,CAAAvL,IAAA,iBAAArG,MACD,SAAegI,GACX,IAAM6J,EAAU7J,EAAM6J,QAChBC,KAAcC,kBAAe/J,GAQnC,GAHI6J,IAAYG,WAAWF,GACvB9J,EAAMiK,iBAENhO,KAAKiO,cAAgBL,IAAYM,SAASlO,KAAKuK,YAAcsD,EAC7D7N,KAAKiO,aAAaE,wBAClBnO,KAAKoO,mBACLrK,EAAMiK,sBAAc,GAEfhO,KAAK8K,aAAc,CACxB,IAAMuD,EAAiBrO,KAAK8K,aAAa7H,YAAY2J,WAC/C0B,EAAaV,IAAYW,YAAYX,IAAYY,aACnDZ,IAAYa,OAAQH,IAAeT,GAAe7N,KAAKuK,UACvDvK,KAAK8K,aAAa7H,YAAYyL,UAAU3K,GAEnCuK,GAActO,KAAK2O,YACxB3O,KAAK4O,aAELN,GAActO,KAAK8K,aAAa7H,YAAY2J,aAAeyB,KAC3DrO,KAAK6O,gBAAgB7O,KAAK8K,aAAa7H,YAAY6L,iBAAmB,GAClE9O,KAAK8K,aAAapK,wBAA0BV,KAAKiO,eAC5CjO,KAAKkM,6BACNlM,KAAK+O,0BAA4B/O,KAAKoJ,SAASrG,cAAchH,OAEjEiE,KAAKkM,2BAA6BlM,KAAKiO,aACvCjO,KAAKyN,mBAAmBzN,KAAKiO,aAAalS,QAAK,CAI/D,GAAC,CAAAqG,IAAA,eAAArG,MACD,SAAagI,GACT,IAAI5K,EAAS4K,EAAM5K,OACf4C,EAAQ5C,EAAO4C,MAEC,WAAhB5C,EAAOsL,OACP1I,EAAiB,IAATA,EAAc,KAAOiT,WAAWjT,IAOxCiE,KAAKiP,iBAAmBlT,IACxBiE,KAAKiP,eAAiBlT,EACtBiE,KAAKkM,2BAA6B,KAClClM,KAAKwK,UAAUzO,GACXiE,KAAK2O,YAAc3O,KAAK2J,UAAUW,gBAAkBvG,EAAM5K,QAC1D6G,KAAK4O,YAGjB,GAAC,CAAAxM,IAAA,eAAArG,MACD,WACSiE,KAAKkK,oBAGDlK,KAAK2O,aACV3O,KAAKiP,eAAiBjP,KAAKoJ,SAASrG,cAAchH,MAClDiE,KAAK6L,iBACL7L,KAAK8L,aAAY,IALjB9L,KAAKkK,qBAAsB,CAOnC,GAAC,CAAA9H,IAAA,eAAArG,MACD,WACQiE,KAAK2O,aAAe3O,KAAKuK,WACzBvK,KAAK4O,WAEb,GACA,CAAAxM,IAAA,cAAArG,MAMA,WACQiE,KAAK0J,YAA6C,SAA/B1J,KAAK0J,WAAWwF,aADlBpX,UAAAC,OAAA,QAAAyB,IAAA1B,UAAA,IAAAA,UAAA,GAGbkI,KAAK0J,WAAWyF,uBAGhBnP,KAAK0J,WAAWwF,WAAa,SAEjClP,KAAKgK,wBAAyB,EAEtC,GACA,CAAA5H,IAAA,cAAArG,MACA,WACQiE,KAAKgK,yBACDhK,KAAK0J,aACL1J,KAAK0J,WAAWwF,WAAa,QAEjClP,KAAKgK,wBAAyB,EAEtC,GACA,CAAA5H,IAAA,6BAAArG,MAIA,WAA6B,IAAAqT,EAAApP,KACnBqP,EAAcrP,KAAKuJ,MAAM2B,SAASzR,QAAKoC,KAAK,IAC5CyT,EAAgBtP,KAAK8K,aAAazR,QAAQ0R,QAAQtR,QAAKmE,MAAI,kBAAMwR,EAAK5D,kBAAkB+D,qBAAqB,MAGnHrT,MAAM,IAEN,SAAQhB,KAAMmU,EAAaC,GACtB7V,QAGLwD,KAAU,WAINmS,SAAK7F,MAAM0C,IAAI,WACX,IAAMuD,EAAUJ,EAAK7E,UACrB6E,EAAKhB,mBACLgB,EAAKtE,aAAarH,iBAClB2L,EAAKnO,mBAAmBqL,gBACpB8C,EAAK7E,WACL6E,EAAK1D,YAAYC,iBAEjB6D,IAAYJ,EAAK7E,YAQb6E,EAAK7E,UACL6E,EAAKtE,aAAajJ,OAAO0B,OAGzB6L,EAAKtE,aAAahJ,OAAOyB,OAGrC,GACO6L,EAAKK,mBAChB,IAAC,EAED5T,KAAK,IAEAjD,UAAU,SAAAmL,GAAK,OAAIqL,EAAKM,kBAAkB3L,EAAM,EACzD,GACA,CAAA3B,IAAA,gBAAArG,MACA,WACQiE,KAAK0L,cACL1L,KAAK2P,aACL3P,KAAK0L,YAAYkE,UACjB5P,KAAK0L,YAAc,KAE3B,GAAC,CAAAtJ,IAAA,qBAAArG,MACD,SAAmBA,GACf,IAAM8T,EAAY7P,KAAK8K,cAAgB9K,KAAK8K,aAAapJ,YACnD1B,KAAK8K,aAAapJ,YAAY3F,GAC9BA,EAGNiE,KAAK8P,wBAAwBD,GAAgC,GACjE,GAAC,CAAAzN,IAAA,0BAAArG,MACD,SAAwBA,GAGhBiE,KAAK0J,WACL1J,KAAK0J,WAAWqG,SAAShU,MAAQA,EAGjCiE,KAAKoJ,SAASrG,cAAchH,MAAQA,EAExCiE,KAAKiP,eAAiBlT,CAC1B,GACA,CAAAqG,IAAA,oBAAArG,MAKA,SAAkBgI,GACd,IAAMiM,EAAWjM,EAAQA,EAAMnI,OAASoE,KAAKkM,2BACzC8D,IACAhQ,KAAKiQ,6BAA6BD,GAClChQ,KAAKyN,mBAAmBuC,EAASjU,OACjCiE,KAAKwK,UAAUwF,EAASjU,OACxBiE,KAAK8K,aAAaoF,iBAAiBF,GACnChQ,KAAKoJ,SAASrG,cAAcoN,SAEhCnQ,KAAK2P,YACT,GACA,CAAAvN,IAAA,+BAAArG,MAGA,SAA6BqU,GACzBpQ,KAAK8K,aAAazR,QAAQgX,QAAQ,SAAAvQ,GAC1BA,IAAWsQ,GAAQtQ,EAAOwQ,UAC1BxQ,EAAOyQ,UAEf,EACJ,GAAC,CAAAnO,IAAA,iBAAArG,MACD,WAAiB,IAAAyU,EAKIC,EALJC,EAAA1Q,KAIT2Q,EAAa3Q,KAAK0L,YACjBiF,GAeD3Q,KAAKwL,kBAAkBoF,UAAU5Q,KAAK6Q,wBACtCF,EAAWG,WAAW,CAAEC,MAAO/Q,KAAKgR,qBAfpChR,KAAKiR,QAAU,IAAIC,iBAAelR,KAAK8K,aAAajG,SAAU7E,KAAKsJ,kBAAmB,CAClF3K,GAAmB,QAAjB8R,EAAEzQ,KAAK0J,kBAAU,IAAA+G,OAAA,EAAfA,EAAiBU,eAEzBR,EAAa3Q,KAAKqJ,SAAS+H,OAAOpR,KAAKqR,qBACvCrR,KAAK0L,YAAciF,EACnB3Q,KAAKsR,qBAAqBX,GAC1B3Q,KAAKiK,sBAAwBjK,KAAK4J,eAAetG,SAAS1K,UAAU,WAC5D8X,EAAKnG,WAAaoG,GAClBA,EAAWG,WAAW,CAAEC,MAAOL,EAAKM,kBAE5C,IAOAL,IAAeA,EAAWxE,gBAC1BwE,EAAWY,OAAOvR,KAAKiR,SACvBjR,KAAKqM,4BAA8BrM,KAAKwR,8BAE5C,IAAMhC,EAAUxP,KAAKuK,UACrBvK,KAAK8K,aAAarH,iBAClBzD,KAAK8K,aAAarJ,QAAUzB,KAAK4K,kBAAmB,EACpD5K,KAAK8K,aAAa2G,UAAyB,QAAhBjB,EAACxQ,KAAK0J,kBAAU,IAAA8G,OAAA,EAAfA,EAAiBkB,OAGzC1R,KAAKuK,WAAaiF,IAAYxP,KAAKuK,WACnCvK,KAAK8K,aAAajJ,OAAO0B,MAEjC,GAAC,CAAAnB,IAAA,oBAAArG,MACD,WAAoB,IAAA4V,EAAAC,EAChB,OAAO,IAAIC,gBAAc,CACrBC,iBAAkB9R,KAAK+R,sBACvBvI,eAAgBxJ,KAAKmL,kBACrB4F,MAAO/Q,KAAKgR,iBACZgB,UAAoB,QAAXL,EAAE3R,KAAKyJ,YAAI,IAAAkI,SAAInY,EACxByY,WAA0B,QAAhBL,EAAE5R,KAAKmB,iBAAS,IAAAyQ,OAAA,EAAdA,EAAgBM,mBAEpC,GAAC,CAAA9P,IAAA,sBAAArG,MACD,WACI,IAAMoW,EAAWnS,KAAKqJ,SACjBqB,WACA0H,oBAAoBpS,KAAK6Q,wBACzBwB,wBAAuB,GACvBC,UAAS,GACd,OAAAtS,KAAKyL,sBAAsB0G,GAC3BnS,KAAKwL,kBAAoB2G,EAClBA,CACX,GACA,CAAA/P,IAAA,wBAAArG,MACA,SAAsB+V,GAGlB,IAYIS,EAZEC,EAAiB,CACnB,CAAEC,QAAS,QAASC,QAAS,SAAUC,SAAU,QAASC,SAAU,OACpE,CAAEH,QAAS,MAAOC,QAAS,SAAUC,SAAU,MAAOC,SAAU,QAK9DX,EAAajS,KAAK6S,YAClBC,EAAiB,CACnB,CAAEL,QAAS,QAASC,QAAS,MAAOC,SAAU,QAASC,SAAU,SAAUX,cAC3E,CAAEQ,QAAS,MAAOC,QAAS,MAAOC,SAAU,MAAOC,SAAU,SAAUX,eAIvEM,EADkB,UAAlBvS,KAAK0K,SACOoI,EAEW,UAAlB9S,KAAK0K,SACE8H,EAGH,GAAA5a,OAAO4a,EAAmBM,GAEvChB,EAAiBiB,cAAcR,EACnC,GAAC,CAAAnQ,IAAA,uBAAArG,MACD,WACI,OAAIiE,KAAKkN,YACElN,KAAKkN,YAAYpF,WAErB9H,KAAK0J,WAAa1J,KAAK0J,WAAWsJ,4BAA8BhT,KAAKoJ,QAChF,GAAC,CAAAhH,IAAA,iBAAArG,MACD,WACI,OAAOiE,KAAK8K,aAAa9F,YAAchF,KAAKiT,eAChD,GACA,CAAA7Q,IAAA,gBAAArG,MACA,WACI,OAAOiE,KAAK6Q,uBAAuB9N,cAAcmQ,wBAAwBnC,KAC7E,GACA,CAAA3O,IAAA,mBAAArG,MAOA,WACI,IAAM+O,EAAe9K,KAAK8K,aAC1B,GAAIA,EAAarK,sBAAuB,CAKpC,QADI0S,GAA0B,EACrBnX,EAAQ,EAAGA,EAAQ8O,EAAazR,QAAQtB,OAAQiE,IAErD,IADe8O,EAAazR,QAAQgJ,IAAIrG,GAC5BoI,SAAU,CAClB+O,EAA0BnX,EAC1B,MAGR8O,EAAa7H,YAAYmQ,cAAcD,EAAuB,MAG9DrI,EAAa7H,YAAYmQ,eAAc,EAE/C,GACA,CAAAhR,IAAA,WAAArG,MACA,WACI,IAAMsX,EAAUrT,KAAKoJ,SAASrG,cAC9B,OAAQsQ,EAAQC,WAAaD,EAAQjP,WAAapE,KAAK+J,qBAC3D,GACA,CAAA3H,IAAA,aAAArG,MACA,WAAa,IAAAwX,EACT,OAAqB,QAAdA,EAAAvT,KAAK2J,iBAAS,IAAA4J,OAAA,EAAdA,EAAgBC,cAAenI,MAC1C,GACA,CAAAjJ,IAAA,kBAAArG,MACA,SAAgBC,GAQZ,IAAM8O,EAAe9K,KAAK8K,aACpB2I,KAAaC,iCAA8B1X,EAAO8O,EAAazR,QAASyR,EAAanE,cAC3F,GAAc,IAAV3K,GAA8B,IAAfyX,EAIf3I,EAAa6I,cAAc,QAAC,GAEvB7I,EAAajH,MAAO,CACzB,IAAM/D,EAASgL,EAAazR,QAAQmK,UAAUxH,GAC9C,GAAI8D,EAAQ,CACR,IAAMuT,EAAUvT,EAAO8T,kBACjBC,KAAoBC,4BAAyBT,EAAQU,UAAWV,EAAQW,aAAclJ,EAAamJ,gBAAiBnJ,EAAajH,MAAMd,cAAciR,cAC3JlJ,EAAa6I,cAAcE,EAAiB,EAGxD,GACA,CAAAzR,IAAA,uBAAArG,MACA,SAAqB4U,GAAY,IAAAuD,EAAAlU,KAG7B2Q,EAAWwD,gBAAgBvb,UAAU,SAAAmL,GAOQ,IAAAqQ,GAJpCrQ,EAAM6J,UAAYG,YAAU,EAACD,kBAAe/J,IAC5CA,EAAM6J,UAAYW,eAAYT,kBAAe/J,EAAO,aAGjDmQ,EAAKhI,6BACLgI,EAAKpE,wBAAsD,QAA/BsE,EAACF,EAAKnF,iCAAyB,IAAAqF,IAAI,IAC/DF,EAAKhI,2BAA6B,MAEtCgI,EAAK/J,qBAAqBlP,OAC1BiZ,EAAK9F,mBAGLrK,EAAMsQ,kBACNtQ,EAAMiK,iBAEd,GAIA2C,EAAW2D,uBAAuB1b,WACtC,KAACuQ,CAAA,CAhlB4B,GAA3BA,SAilBY9E,UAAI,SAAAC,GAAA,WAAAA,GAAwF6E,GAhvBV1K,8BAgvBuDA,cAhvBvDA,8BAgvBiF8V,WAhvBjF9V,8BAgvB0GA,oBAhvB1GA,8BAgvB0IA,UAhvB1IA,8BAgvBgKA,qBAhvBhKA,8BAgvBiMiK,GAhvBjMjK,8BAgvB8O+V,kBAAmB,GAhvBjQ/V,8BAgvB8RgW,iBAAc,GAhvB5ShW,8BAgvBqViW,WAAQ,GAhvB7VjW,8BAgvB0XkW,iBAhvB1XlW,8BAgvBuZ2B,EAAgC,KAjlBrhB+I,EAklBY3E,UAjvBkF/F,8BAAE,CAAAgG,KAivBJ0E,EAA2BpE,OAAA,CAAA+F,aAAA,mCAAAJ,SAAA,uCAAAwC,YAAA,6CAAAvC,sBAAA,yCAAAiK,qBAAA,oDAAA1P,SAAA,CAjvBzBzG,oCA+J9F0K,CAA2B,IA4nB3Bb,EAAsB,eAAtBA,EAAsB,SAAAuM,IAAA/T,OAAAwH,EAAAuM,GAAA,IAAAC,KAAA9T,KAAAsH,GACxB,SAAAA,IAAc,IAAAyM,EAAAhV,cAAAC,KAAAsI,IACVyM,EAAAD,EAAAtP,MAAAxF,KAASlI,YACJ+a,YAAc,mCAAmCkC,CAC1D,CAAC,SAAAlV,KAAAyI,EAAA,CAJuB,CAASa,GAA/Bb,SAKYjE,UAAI,eAAA2Q,EAAA,gBAAA1Q,GAAA,OAAA0Q,MAhyB8EvW,kCAgyBU6J,KAAsBhE,GAAtBgE,EAAsB,EAA9G,GALhBA,EAMY9D,UAjyBkF/F,8BAAE,CAAAgG,KAiyBJ6D,EAAsBhC,UAAA,mEAAAM,UAAA,mCAAAqO,SAAA,EAAAC,aAAA,SAAA3W,EAAAC,GAAA,EAAAD,GAjyBpBE,uBAAE,4BAiyBJD,EAAA2W,cAAc,EAjyBZ1W,CAiyBY,yBAAdD,EAAAiM,YAAY,EAjyBVhM,CAiyBU,iBAAA2W,GAAA,OAAZ5W,EAAA6W,aAAAD,EAAoB,EAjyBlB3W,CAiyBkB,mBAAA2W,GAAA,OAApB5W,EAAA8W,eAAAF,EAAsB,EAjyBpB3W,CAiyBoB,0BAAtBD,EAAA+W,cAAc,KAAAhX,GAjyBZE,wBAAE,eAAAD,EAAAmM,sBAAFlM,CAAE,OAAAD,EAAAoW,qBAAA,gBAAFnW,CAAE,oBAAAD,EAAAoW,qBAAA,YAAFnW,CAAE,wBAAAD,EAAA+L,WAAA/L,EAAAyP,aAAAzP,EAAAyP,aAAAtP,GAAA,KAAFF,CAAE,gBAAAD,EAAAoW,qBAAA,KAAApW,EAAA+L,UAAAiL,WAAF/W,CAAE,YAAAD,EAAAoW,uBAAApW,EAAA+L,WAAA,MAAA/L,EAAAsM,aAAA,KAAAtM,EAAAsM,aAAAnM,GAAFF,CAAE,gBAAAD,EAAAoW,qBAAA,iBAAA9N,SAAA,2BAAA5B,SAAA,CAAFzG,+BAiyBqzB,CAAC0J,IAjyBtzB1J,0CA2xB9F6J,CAAsB,IAkCtBmN,GAAqB,eAArBA,GAAqB5V,OAAA,SAAA4V,KAAA1V,OAAAC,KAAAyV,EAAA,GAArBA,SACYpR,UAAI,SAAAC,GAAA,WAAAA,GAAwFmR,EAAqB,EAD7HA,EAEYC,UA/zBkFjX,6BAAE,CAAAgG,KA+zBSgR,IAFzGA,EAQYE,UAr0BkFlX,6BAAE,CAAAmX,UAq0B2C,CAAC7M,GAAkD8M,QAAA,CAAYC,gBAAeC,kBAAiBC,kBAAiBC,eAAcC,sBACnQH,kBACAC,qBAVNP,CAAqB","names":["concat","_len","arguments","length","args","Array","_key","concatAll","mergeAll","from","popScheduler","defer","observableFactory","Observable","subscriber","innerFrom","subscribe","EMPTY","complete","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","target","eventName","options","resultSelector","isFunction","undefined","pipe","mapOneOrManyArgs","_ref","isEventTarget","addEventListener","removeEventListener","map","methodName","handler","isNodeStyleEventEmitter","addListener","removeListener","toCommonHandlerRegistry","isJQueryStyleEventEmitter","on","off","_ref2","_slicedToArray","add","remove","isArrayLike","mergeMap","subTarget","TypeError","next","merge","scheduler","concurrent","popNumber","Infinity","sources","of","delayWhen","delayDurationSelector","subscriptionDelay","source","take","ignoreElements","value","index","mapTo","delay","due","duration","timer","asyncScheduler","filter","predicate","thisArg","operate","createOperatorSubscriber","call","noop","identity","startWith","values","switchMap","project","innerSubscriber","isComplete","checkComplete","unsubscribe","innerIndex","outerIndex","innerValue","count","seen","tap","observerOrNext","error","tapObserver","_a","isUnsub","err","_b","finalize","_c0","MatAutocomplete_ng_template_0_Template","rf","ctx","i0","formFieldId_r1","id","ctx_r0","_classList","isOpen","ariaLabel","_getPanelAriaLabelledby","_c1","panelAnimation","trigger","state","style","opacity","transform","transition","group","animate","_uniqueAutocompleteIdCounter","MatAutocompleteSelectedEvent","_createClass","option","_classCallCheck","this","_MatAutocompleteMixinBase","mixinDisableRipple","_class","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","autoSelectActiveOption","hideSingleSelectionIndicator","_MatAutocompleteBase","_MatAutocompleteMixin","_inherits","_super","_createSuper","_changeDetectorRef","_elementRef","_defaults","platform","_this","_activeOptionChanges","Subscription","showPanel","_isOpen","displayWith","optionSelected","EventEmitter","opened","closed","optionActivated","inertGroups","SAFARI","_autoActiveFirstOption","_autoSelectActiveOption","key","get","_color","_setThemeClasses","set","coerceBooleanProperty","coerceStringArray","reduce","classList","className","_setVisibilityClasses","nativeElement","_this2","_keyManager","ActiveDescendantKeyManager","withWrap","skipPredicate","_skipPredicate","change","emit","toArray","_setVisibility","_this$_keyManager","destroy","scrollTop","panel","markForCheck","event","labelId","ariaLabelledby","_visibleClass","_hiddenClass","disabled","ɵfac","t","i1","ɵdir","type","viewQuery","_t","TemplateRef","template","first","inputs","panelWidth","outputs","features","MatAutocomplete","_MatAutocompleteBase2","_super2","_this3$_defaults$hide","_this3","apply","_hideSingleSelectionIndicator","_syncParentProperties","_step","_iterator","_createForOfIteratorHelper","s","n","done","e","f","_option","ɵMatAutocomplete_BaseFactory","ɵcmp","selectors","contentQueries","dirIndex","MAT_OPTGROUP","MatOption","optionGroups","hostAttrs","disableRipple","exportAs","provide","MAT_OPTION_PARENT_COMPONENT","useExisting","ngContentSelectors","decls","vars","consts","dependencies","i2","styles","encapsulation","data","animation","changeDetection","_MatAutocompleteOriginBase","elementRef","MatAutocompleteOrigin","_MatAutocompleteOrigi","_super3","ɵMatAutocompleteOrigin_BaseFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","Error","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","_MatAutocompleteTriggerBase","_element","_overlay","_viewContainerRef","_zone","scrollStrategy","_dir","_formField","_document","_viewportRuler","_this4","_componentDestroyed","_autocompleteDisabled","_manuallyFloatingLabel","_viewportSubscription","_canOpenOnNextFocus","_closeKeyEventStream","Subject","_windowBlurHandler","activeElement","panelOpen","_onChange","_onTouched","position","autocompleteAttribute","_overlayAttached","optionSelections","autocomplete","changes","_toConsumableArray","onSelectionChange","onStable","_scrollStrategy","_this5","window","_getWindow","runOutsideAngular","_positionStrategy","_setStrategyPositions","_overlayRef","updatePosition","_destroyPanel","_attachOverlay","_floatLabel","_this6","_resetLabel","run","_pendingAutoselectedOption","hasAttached","detach","_closingActionsSubscription","detectChanges","_this7","tabOut","_getOutsideClickStream","detachments","MatOptionSelectionChange","activeItem","_this8","clickTarget","_getEventTarget","formField","customOrigin","connectedTo","contains","overlayElement","_this9","Promise","resolve","then","_assignOptionValue","fn","isDisabled","keyCode","hasModifier","hasModifierKey","ESCAPE","preventDefault","activeOption","ENTER","_selectViaInteraction","_resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","onKeydown","_canOpen","openPanel","_scrollToOption","activeItemIndex","_valueBeforeAutoSelection","parseFloat","_previousValue","floatLabel","_animateAndLockLabel","_this10","firstStable","optionChanges","reapplyLastPosition","wasOpen","panelClosingActions","_setValueAndClose","closePanel","dispose","toDisplay","_updateNativeInputValue","_control","toSelect","_clearPreviousSelectedOption","_emitSelectEvent","focus","skip","forEach","selected","deselect","_this$_formField2","_this$_formField","_this11","overlayRef","setOrigin","_getConnectedElement","updateSize","width","_getPanelWidth","_portal","TemplatePortal","getLabelId","create","_getOverlayConfig","_handleOverlayEvents","attach","_subscribeToClosingActions","_setColor","color","_this$_dir","_this$_defaults","OverlayConfig","positionStrategy","_getOverlayPosition","direction","panelClass","overlayPanelClass","strategy","flexibleConnectedTo","withFlexibleDimensions","withPush","positions","belowPositions","originX","originY","overlayX","overlayY","_aboveClass","abovePositions","withPositions","getConnectedOverlayOrigin","_getHostWidth","getBoundingClientRect","firstEnabledOptionIndex","setActiveItem","element","readOnly","_this$_document","defaultView","labelCount","_countGroupLabelsBeforeOption","_setScrollTop","_getHostElement","newScrollPosition","_getOptionScrollPosition","offsetTop","offsetHeight","_getScrollTop","_this12","keydownEvents","_this12$_valueBeforeA","stopPropagation","outsidePointerEvents","i1$1","i2$1","MAT_FORM_FIELD","DOCUMENT","i3","autocompleteDisabled","_MatAutocompleteTrigg","_super4","_this13","ɵMatAutocompleteTrigger_BaseFactory","hostVars","hostBindings","_handleFocus","$event","_handleInput","_handleKeydown","_handleClick","toString","MatAutocompleteModule","ɵmod","ɵinj","providers","imports","OverlayModule","MatOptionModule","MatCommonModule","CommonModule","CdkScrollableModule"],"sourceRoot":"webpack:///","sources":["./node_modules/rxjs/dist/esm/internal/observable/concat.js","./node_modules/rxjs/dist/esm/internal/operators/concatAll.js","./node_modules/rxjs/dist/esm/internal/observable/defer.js","./node_modules/rxjs/dist/esm/internal/observable/empty.js","./node_modules/rxjs/dist/esm/internal/observable/fromEvent.js","./node_modules/rxjs/dist/esm/internal/observable/merge.js","./node_modules/rxjs/dist/esm/internal/observable/of.js","./node_modules/rxjs/dist/esm/internal/operators/delayWhen.js","./node_modules/rxjs/dist/esm/internal/operators/delay.js","./node_modules/rxjs/dist/esm/internal/operators/filter.js","./node_modules/rxjs/dist/esm/internal/operators/ignoreElements.js","./node_modules/rxjs/dist/esm/internal/operators/mapTo.js","./node_modules/rxjs/dist/esm/internal/operators/mergeAll.js","./node_modules/rxjs/dist/esm/internal/operators/startWith.js","./node_modules/rxjs/dist/esm/internal/operators/switchMap.js","./node_modules/rxjs/dist/esm/internal/operators/take.js","./node_modules/rxjs/dist/esm/internal/operators/tap.js","./node_modules/@angular/material/fesm2022/autocomplete.mjs"],"sourcesContent":["import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat(...args) {\n    return concatAll()(from(args, popScheduler(args)));\n}\n","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nexport function defer(observableFactory) {\n    return new Observable((subscriber) => {\n        innerFrom(observableFactory()).subscribe(subscriber);\n    });\n}\n","import { Observable } from '../Observable';\nexport const EMPTY = new Observable((subscriber) => subscriber.complete());\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'];\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'];\nconst jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    const [add, remove] = isEventTarget(target)\n        ? eventTargetMethods.map((methodName) => (handler) => target[methodName](eventName, handler, options))\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [];\n    if (!add) {\n        if (isArrayLike(target)) {\n            return mergeMap((subTarget) => fromEvent(subTarget, eventName, options))(innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable((subscriber) => {\n        const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);\n        add(handler);\n        return () => remove(handler);\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return (methodName) => (handler) => target[methodName](eventName, handler);\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n","import { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\nexport function merge(...args) {\n    const scheduler = popScheduler(args);\n    const concurrent = popNumber(args, Infinity);\n    const sources = args;\n    return !sources.length\n        ?\n            EMPTY\n        : sources.length === 1\n            ?\n                innerFrom(sources[0])\n            :\n                mergeAll(concurrent)(from(sources, scheduler));\n}\n","import { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function of(...args) {\n    const scheduler = popScheduler(args);\n    return from(args, scheduler);\n}\n","import { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nexport function delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return (source) => concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n    }\n    return mergeMap((value, index) => delayDurationSelector(value, index).pipe(take(1), mapTo(value)));\n}\n","import { asyncScheduler } from '../scheduler/async';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\nexport function delay(due, scheduler = asyncScheduler) {\n    const duration = timer(due, scheduler);\n    return delayWhen(() => duration);\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nexport function ignoreElements() {\n    return operate((source, subscriber) => {\n        source.subscribe(createOperatorSubscriber(subscriber, noop));\n    });\n}\n","import { map } from './map';\nexport function mapTo(value) {\n    return map(() => value);\n}\n","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent = Infinity) {\n    return mergeMap(identity, concurrent);\n}\n","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith(...values) {\n    const scheduler = popScheduler(values);\n    return operate((source, subscriber) => {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n","import { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function switchMap(project, resultSelector) {\n    return operate((source, subscriber) => {\n        let innerSubscriber = null;\n        let index = 0;\n        let isComplete = false;\n        const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n            let innerIndex = 0;\n            const outerIndex = index++;\n            innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n                innerSubscriber = null;\n                checkComplete();\n            })));\n        }, () => {\n            isComplete = true;\n            checkComplete();\n        }));\n    });\n}\n","import { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function take(count) {\n    return count <= 0\n        ?\n            () => EMPTY\n        : operate((source, subscriber) => {\n            let seen = 0;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                if (++seen <= count) {\n                    subscriber.next(value);\n                    if (count <= seen) {\n                        subscriber.complete();\n                    }\n                }\n            }));\n        });\n}\n","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    const tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error, complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate((source, subscriber) => {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            let isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, () => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, (err) => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, () => {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n","import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, TemplateRef, Directive, Inject, ViewChild, Input, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChildren, forwardRef, Optional, Host, NgModule } from '@angular/core';\nimport { mixinDisableRipple, MAT_OPTION_PARENT_COMPONENT, MAT_OPTGROUP, MatOption, MatOptionSelectionChange, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionModule, MatCommonModule } from '@angular/material/core';\nimport * as i2 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i3 from '@angular/cdk/scrolling';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty, coerceStringArray } from '@angular/cdk/coercion';\nimport * as i1 from '@angular/cdk/platform';\nimport { _getEventTarget } from '@angular/cdk/platform';\nimport { trigger, state, style, transition, group, animate } from '@angular/animations';\nimport { Subscription, Subject, defer, merge, of, fromEvent } from 'rxjs';\nimport { hasModifierKey, ESCAPE, ENTER, UP_ARROW, DOWN_ARROW, TAB } from '@angular/cdk/keycodes';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport * as i4 from '@angular/material/form-field';\nimport { MAT_FORM_FIELD } from '@angular/material/form-field';\nimport { startWith, switchMap, take, filter, map, tap, delay } from 'rxjs/operators';\nimport * as i2$1 from '@angular/cdk/bidi';\n\n// Animation values come from\n// https://github.com/material-components/material-components-web/blob/master/packages/mdc-menu-surface/_mixins.scss\n// TODO(mmalerba): Ideally find a way to import the values from MDC's code.\nconst panelAnimation = trigger('panelAnimation', [\n    state('void, hidden', style({\n        opacity: 0,\n        transform: 'scaleY(0.8)',\n    })),\n    transition(':enter, hidden => visible', [\n        group([\n            animate('0.03s linear', style({ opacity: 1 })),\n            animate('0.12s cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scaleY(1)' })),\n        ]),\n    ]),\n    transition(':leave, visible => hidden', [animate('0.075s linear', style({ opacity: 0 }))]),\n]);\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueAutocompleteIdCounter = 0;\n/** Event object that is emitted when an autocomplete option is selected. */\nclass MatAutocompleteSelectedEvent {\n    constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    source, \n    /** Option that was selected. */\n    option) {\n        this.source = source;\n        this.option = option;\n    }\n}\n// Boilerplate for applying mixins to MatAutocomplete.\n/** @docs-private */\nconst _MatAutocompleteMixinBase = mixinDisableRipple(class {\n});\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options', {\n    providedIn: 'root',\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n});\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        autoActiveFirstOption: false,\n        autoSelectActiveOption: false,\n        hideSingleSelectionIndicator: false,\n    };\n}\n/** Base class with all of the `MatAutocomplete` functionality. */\nclass _MatAutocompleteBase extends _MatAutocompleteMixinBase {\n    /** Whether the autocomplete panel is open. */\n    get isOpen() {\n        return this._isOpen && this.showPanel;\n    }\n    /** @docs-private Sets the theme color of the panel. */\n    _setColor(value) {\n        this._color = value;\n        this._setThemeClasses(this._classList);\n    }\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    get autoActiveFirstOption() {\n        return this._autoActiveFirstOption;\n    }\n    set autoActiveFirstOption(value) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n    /** Whether the active option should be selected as the user is navigating. */\n    get autoSelectActiveOption() {\n        return this._autoSelectActiveOption;\n    }\n    set autoSelectActiveOption(value) {\n        this._autoSelectActiveOption = coerceBooleanProperty(value);\n    }\n    /**\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    set classList(value) {\n        if (value && value.length) {\n            this._classList = coerceStringArray(value).reduce((classList, className) => {\n                classList[className] = true;\n                return classList;\n            }, {});\n        }\n        else {\n            this._classList = {};\n        }\n        this._setVisibilityClasses(this._classList);\n        this._setThemeClasses(this._classList);\n        this._elementRef.nativeElement.className = '';\n    }\n    constructor(_changeDetectorRef, _elementRef, _defaults, platform) {\n        super();\n        this._changeDetectorRef = _changeDetectorRef;\n        this._elementRef = _elementRef;\n        this._defaults = _defaults;\n        this._activeOptionChanges = Subscription.EMPTY;\n        /** Whether the autocomplete panel should be visible, depending on option length. */\n        this.showPanel = false;\n        this._isOpen = false;\n        /** Function that maps an option's control value to its display value in the trigger. */\n        this.displayWith = null;\n        /** Event that is emitted whenever an option from the list is selected. */\n        this.optionSelected = new EventEmitter();\n        /** Event that is emitted when the autocomplete panel is opened. */\n        this.opened = new EventEmitter();\n        /** Event that is emitted when the autocomplete panel is closed. */\n        this.closed = new EventEmitter();\n        /** Emits whenever an option is activated. */\n        this.optionActivated = new EventEmitter();\n        this._classList = {};\n        /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n        this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n        // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\n        // Safari using VoiceOver. We should occasionally check back to see whether the bug\n        // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\n        // option altogether.\n        this.inertGroups = platform?.SAFARI || false;\n        this._autoActiveFirstOption = !!_defaults.autoActiveFirstOption;\n        this._autoSelectActiveOption = !!_defaults.autoSelectActiveOption;\n    }\n    ngAfterContentInit() {\n        this._keyManager = new ActiveDescendantKeyManager(this.options)\n            .withWrap()\n            .skipPredicate(this._skipPredicate);\n        this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n            if (this.isOpen) {\n                this.optionActivated.emit({ source: this, option: this.options.toArray()[index] || null });\n            }\n        });\n        // Set the initial visibility state.\n        this._setVisibility();\n    }\n    ngOnDestroy() {\n        this._keyManager?.destroy();\n        this._activeOptionChanges.unsubscribe();\n    }\n    /**\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\n     * above or below the fold, as they are not actually being focused when active.\n     */\n    _setScrollTop(scrollTop) {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n    /** Returns the panel's scrollTop. */\n    _getScrollTop() {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n    /** Panel should hide itself when the option list is empty. */\n    _setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._setVisibilityClasses(this._classList);\n        this._changeDetectorRef.markForCheck();\n    }\n    /** Emits the `select` event. */\n    _emitSelectEvent(option) {\n        const event = new MatAutocompleteSelectedEvent(this, option);\n        this.optionSelected.emit(event);\n    }\n    /** Gets the aria-labelledby for the autocomplete panel. */\n    _getPanelAriaLabelledby(labelId) {\n        if (this.ariaLabel) {\n            return null;\n        }\n        const labelExpression = labelId ? labelId + ' ' : '';\n        return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n    }\n    /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n    _setVisibilityClasses(classList) {\n        classList[this._visibleClass] = this.showPanel;\n        classList[this._hiddenClass] = !this.showPanel;\n    }\n    /** Sets the theming classes on a classlist based on the theme of the panel. */\n    _setThemeClasses(classList) {\n        classList['mat-primary'] = this._color === 'primary';\n        classList['mat-warn'] = this._color === 'warn';\n        classList['mat-accent'] = this._color === 'accent';\n    }\n    _skipPredicate(option) {\n        return option.disabled;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteBase, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS }, { token: i1.Platform }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: _MatAutocompleteBase, inputs: { ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], displayWith: \"displayWith\", autoActiveFirstOption: \"autoActiveFirstOption\", autoSelectActiveOption: \"autoSelectActiveOption\", panelWidth: \"panelWidth\", classList: [\"class\", \"classList\"] }, outputs: { optionSelected: \"optionSelected\", opened: \"opened\", closed: \"closed\", optionActivated: \"optionActivated\" }, viewQueries: [{ propertyName: \"template\", first: true, predicate: TemplateRef, descendants: true, static: true }, { propertyName: \"panel\", first: true, predicate: [\"panel\"], descendants: true }], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteBase, decorators: [{\n            type: Directive\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\n                }] }, { type: i1.Platform }]; }, propDecorators: { template: [{\n                type: ViewChild,\n                args: [TemplateRef, { static: true }]\n            }], panel: [{\n                type: ViewChild,\n                args: ['panel']\n            }], ariaLabel: [{\n                type: Input,\n                args: ['aria-label']\n            }], ariaLabelledby: [{\n                type: Input,\n                args: ['aria-labelledby']\n            }], displayWith: [{\n                type: Input\n            }], autoActiveFirstOption: [{\n                type: Input\n            }], autoSelectActiveOption: [{\n                type: Input\n            }], panelWidth: [{\n                type: Input\n            }], optionSelected: [{\n                type: Output\n            }], opened: [{\n                type: Output\n            }], closed: [{\n                type: Output\n            }], optionActivated: [{\n                type: Output\n            }], classList: [{\n                type: Input,\n                args: ['class']\n            }] } });\nclass MatAutocomplete extends _MatAutocompleteBase {\n    constructor() {\n        super(...arguments);\n        this._visibleClass = 'mat-mdc-autocomplete-visible';\n        this._hiddenClass = 'mat-mdc-autocomplete-hidden';\n        this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? false;\n    }\n    /** Whether checkmark indicator for single-selection options is hidden. */\n    get hideSingleSelectionIndicator() {\n        return this._hideSingleSelectionIndicator;\n    }\n    set hideSingleSelectionIndicator(value) {\n        this._hideSingleSelectionIndicator = coerceBooleanProperty(value);\n        this._syncParentProperties();\n    }\n    /** Syncs the parent state with the individual options. */\n    _syncParentProperties() {\n        if (this.options) {\n            for (const option of this.options) {\n                option._changeDetectorRef.markForCheck();\n            }\n        }\n    }\n    // `skipPredicate` determines if key manager should avoid putting a given option in the tab\n    // order. Allow disabled list items to receive focus via keyboard to align with WAI ARIA\n    // recommendation.\n    //\n    // Normally WAI ARIA's instructions are to exclude disabled items from the tab order, but it\n    // makes a few exceptions for compound widgets.\n    //\n    // From [Developing a Keyboard Interface](\n    // https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/):\n    //   \"For the following composite widget elements, keep them focusable when disabled: Options in a\n    //   Listbox...\"\n    //\n    // The user can focus disabled options using the keyboard, but the user cannot click disabled\n    // options.\n    _skipPredicate(_option) {\n        return false;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocomplete, deps: null, target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.0.0\", type: MatAutocomplete, selector: \"mat-autocomplete\", inputs: { disableRipple: \"disableRipple\", hideSingleSelectionIndicator: \"hideSingleSelectionIndicator\" }, host: { attributes: { \"ngSkipHydration\": \"\" }, classAttribute: \"mat-mdc-autocomplete\" }, providers: [{ provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }], queries: [{ propertyName: \"optionGroups\", predicate: MAT_OPTGROUP, descendants: true }, { propertyName: \"options\", predicate: MatOption, descendants: true }], exportAs: [\"matAutocomplete\"], usesInheritance: true, ngImport: i0, template: \"<ng-template let-formFieldId=\\\"id\\\">\\n  <div\\n    class=\\\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\\\"\\n    role=\\\"listbox\\\"\\n    [id]=\\\"id\\\"\\n    [ngClass]=\\\"_classList\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby(formFieldId)\\\"\\n    [@panelAnimation]=\\\"isOpen ? 'visible' : 'hidden'\\\"\\n    #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\", styles: [\".mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mdc-menu-surface{max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px)}.mdc-menu-surface.mat-mdc-autocomplete-panel{width:100%;max-height:256px;position:static;visibility:hidden;transform-origin:center top;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-autocomplete-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) .mdc-menu-surface.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above .mdc-menu-surface.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden}mat-autocomplete{display:none}\"], dependencies: [{ kind: \"directive\", type: i2.NgClass, selector: \"[ngClass]\", inputs: [\"class\", \"ngClass\"] }], animations: [panelAnimation], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocomplete, decorators: [{\n            type: Component,\n            args: [{ selector: 'mat-autocomplete', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'matAutocomplete', inputs: ['disableRipple'], host: {\n                        'class': 'mat-mdc-autocomplete',\n                        'ngSkipHydration': '',\n                    }, providers: [{ provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }], animations: [panelAnimation], template: \"<ng-template let-formFieldId=\\\"id\\\">\\n  <div\\n    class=\\\"mat-mdc-autocomplete-panel mdc-menu-surface mdc-menu-surface--open\\\"\\n    role=\\\"listbox\\\"\\n    [id]=\\\"id\\\"\\n    [ngClass]=\\\"_classList\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby(formFieldId)\\\"\\n    [@panelAnimation]=\\\"isOpen ? 'visible' : 'hidden'\\\"\\n    #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\", styles: [\".mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mdc-menu-surface{max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px)}.mdc-menu-surface.mat-mdc-autocomplete-panel{width:100%;max-height:256px;position:static;visibility:hidden;transform-origin:center top;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-autocomplete-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) .mdc-menu-surface.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above .mdc-menu-surface.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}.mdc-menu-surface.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden}mat-autocomplete{display:none}\"] }]\n        }], propDecorators: { optionGroups: [{\n                type: ContentChildren,\n                args: [MAT_OPTGROUP, { descendants: true }]\n            }], options: [{\n                type: ContentChildren,\n                args: [MatOption, { descendants: true }]\n            }], hideSingleSelectionIndicator: [{\n                type: Input\n            }] } });\n\n/** Base class containing all of the functionality for `MatAutocompleteOrigin`. */\nclass _MatAutocompleteOriginBase {\n    constructor(\n    /** Reference to the element on which the directive is applied. */\n    elementRef) {\n        this.elementRef = elementRef;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteOriginBase, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: _MatAutocompleteOriginBase, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteOriginBase, decorators: [{\n            type: Directive\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\nclass MatAutocompleteOrigin extends _MatAutocompleteOriginBase {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteOrigin, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: MatAutocompleteOrigin, selector: \"[matAutocompleteOrigin]\", exportAs: [\"matAutocompleteOrigin\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteOrigin, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[matAutocompleteOrigin]',\n                    exportAs: 'matAutocompleteOrigin',\n                }]\n        }] });\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => MatAutocompleteTrigger),\n    multi: true,\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nfunction getMatAutocompleteMissingPanelError() {\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n        \"you're attempting to open it after the ngAfterContentInit hook.\");\n}\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n};\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\nclass _MatAutocompleteTriggerBase {\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    get autocompleteDisabled() {\n        return this._autocompleteDisabled;\n    }\n    set autocompleteDisabled(value) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {\n        this._element = _element;\n        this._overlay = _overlay;\n        this._viewContainerRef = _viewContainerRef;\n        this._zone = _zone;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._formField = _formField;\n        this._document = _document;\n        this._viewportRuler = _viewportRuler;\n        this._defaults = _defaults;\n        this._componentDestroyed = false;\n        this._autocompleteDisabled = false;\n        /** Whether or not the label state is being overridden. */\n        this._manuallyFloatingLabel = false;\n        /** Subscription to viewport size changes. */\n        this._viewportSubscription = Subscription.EMPTY;\n        /**\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n         * closed autocomplete from being reopened if the user switches to another browser tab and then\n         * comes back.\n         */\n        this._canOpenOnNextFocus = true;\n        /** Stream of keyboard events that can close the panel. */\n        this._closeKeyEventStream = new Subject();\n        /**\n         * Event handler for when the window is blurred. Needs to be an\n         * arrow function in order to preserve the context.\n         */\n        this._windowBlurHandler = () => {\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\n            // refocused when they come back. In this case we want to skip the first focus event, if the\n            // pane was closed, in order to avoid reopening it unintentionally.\n            this._canOpenOnNextFocus =\n                this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n        };\n        /** `View -> model callback called when value changes` */\n        this._onChange = () => { };\n        /** `View -> model callback called when autocomplete has been touched` */\n        this._onTouched = () => { };\n        /**\n         * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n         * will render the panel underneath the trigger if there is enough space for it to fit in\n         * the viewport, otherwise the panel will be shown above it. If the position is set to\n         * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n         * whether it fits completely in the viewport.\n         */\n        this.position = 'auto';\n        /**\n         * `autocomplete` attribute to be set on the input element.\n         * @docs-private\n         */\n        this.autocompleteAttribute = 'off';\n        this._overlayAttached = false;\n        /** Stream of changes to the selection state of the autocomplete options. */\n        this.optionSelections = defer(() => {\n            const options = this.autocomplete ? this.autocomplete.options : null;\n            if (options) {\n                return options.changes.pipe(startWith(options), switchMap(() => merge(...options.map(option => option.onSelectionChange))));\n            }\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n            // Return a stream that we'll replace with the real one once everything is in place.\n            return this._zone.onStable.pipe(take(1), switchMap(() => this.optionSelections));\n        });\n        this._scrollStrategy = scrollStrategy;\n    }\n    ngAfterViewInit() {\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['position'] && this._positionStrategy) {\n            this._setStrategyPositions(this._positionStrategy);\n            if (this.panelOpen) {\n                this._overlayRef.updatePosition();\n            }\n        }\n    }\n    ngOnDestroy() {\n        const window = this._getWindow();\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this._windowBlurHandler);\n        }\n        this._viewportSubscription.unsubscribe();\n        this._componentDestroyed = true;\n        this._destroyPanel();\n        this._closeKeyEventStream.complete();\n    }\n    /** Whether or not the autocomplete panel is open. */\n    get panelOpen() {\n        return this._overlayAttached && this.autocomplete.showPanel;\n    }\n    /** Opens the autocomplete suggestion panel. */\n    openPanel() {\n        this._attachOverlay();\n        this._floatLabel();\n    }\n    /** Closes the autocomplete suggestion panel. */\n    closePanel() {\n        this._resetLabel();\n        if (!this._overlayAttached) {\n            return;\n        }\n        if (this.panelOpen) {\n            // Only emit if the panel was visible.\n            // The `NgZone.onStable` always emits outside of the Angular zone,\n            // so all the subscriptions from `_subscribeToClosingActions()` are also outside of the Angular zone.\n            // We should manually run in Angular zone to update UI after panel closing.\n            this._zone.run(() => {\n                this.autocomplete.closed.emit();\n            });\n        }\n        this.autocomplete._isOpen = this._overlayAttached = false;\n        this._pendingAutoselectedOption = null;\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\n            this._overlayRef.detach();\n            this._closingActionsSubscription.unsubscribe();\n        }\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this._componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this._changeDetectorRef.detectChanges();\n        }\n    }\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition() {\n        if (this._overlayAttached) {\n            this._overlayRef.updatePosition();\n        }\n    }\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions() {\n        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef\n            ? this._overlayRef.detachments().pipe(filter(() => this._overlayAttached))\n            : of()).pipe(\n        // Normalize the output so we return a consistent type.\n        map(event => (event instanceof MatOptionSelectionChange ? event : null)));\n    }\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption() {\n        if (this.autocomplete && this.autocomplete._keyManager) {\n            return this.autocomplete._keyManager.activeItem;\n        }\n        return null;\n    }\n    /** Stream of clicks outside of the autocomplete panel. */\n    _getOutsideClickStream() {\n        return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'auxclick'), fromEvent(this._document, 'touchend')).pipe(filter(event => {\n            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n            // fall back to check the first element in the path of the click event.\n            const clickTarget = _getEventTarget(event);\n            const formField = this._formField ? this._formField._elementRef.nativeElement : null;\n            const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n            return (this._overlayAttached &&\n                clickTarget !== this._element.nativeElement &&\n                // Normally focus moves inside `mousedown` so this condition will almost always be\n                // true. Its main purpose is to handle the case where the input is focused from an\n                // outside click which propagates up to the `body` listener within the same sequence\n                // and causes the panel to close immediately (see #3106).\n                this._document.activeElement !== this._element.nativeElement &&\n                (!formField || !formField.contains(clickTarget)) &&\n                (!customOrigin || !customOrigin.contains(clickTarget)) &&\n                !!this._overlayRef &&\n                !this._overlayRef.overlayElement.contains(clickTarget));\n        }));\n    }\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value) {\n        Promise.resolve(null).then(() => this._assignOptionValue(value));\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn) {\n        this._onChange = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled) {\n        this._element.nativeElement.disabled = isDisabled;\n    }\n    _handleKeydown(event) {\n        const keyCode = event.keyCode;\n        const hasModifier = hasModifierKey(event);\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE && !hasModifier) {\n            event.preventDefault();\n        }\n        if (this.activeOption && keyCode === ENTER && this.panelOpen && !hasModifier) {\n            this.activeOption._selectViaInteraction();\n            this._resetActiveItem();\n            event.preventDefault();\n        }\n        else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete._keyManager.activeItem;\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n            if (keyCode === TAB || (isArrowKey && !hasModifier && this.panelOpen)) {\n                this.autocomplete._keyManager.onKeydown(event);\n            }\n            else if (isArrowKey && this._canOpen()) {\n                this.openPanel();\n            }\n            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n                if (this.autocomplete.autoSelectActiveOption && this.activeOption) {\n                    if (!this._pendingAutoselectedOption) {\n                        this._valueBeforeAutoSelection = this._element.nativeElement.value;\n                    }\n                    this._pendingAutoselectedOption = this.activeOption;\n                    this._assignOptionValue(this.activeOption.value);\n                }\n            }\n        }\n    }\n    _handleInput(event) {\n        let target = event.target;\n        let value = target.value;\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value == '' ? null : parseFloat(value);\n        }\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this._previousValue !== value) {\n            this._previousValue = value;\n            this._pendingAutoselectedOption = null;\n            this._onChange(value);\n            if (this._canOpen() && this._document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n    _handleFocus() {\n        if (!this._canOpenOnNextFocus) {\n            this._canOpenOnNextFocus = true;\n        }\n        else if (this._canOpen()) {\n            this._previousValue = this._element.nativeElement.value;\n            this._attachOverlay();\n            this._floatLabel(true);\n        }\n    }\n    _handleClick() {\n        if (this._canOpen() && !this.panelOpen) {\n            this.openPanel();\n        }\n    }\n    /**\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\n     * This causes the value to jump when selecting an option with the mouse.\n     * This method manually floats the label until the panel can be closed.\n     * @param shouldAnimate Whether the label should be animated when it is floated.\n     */\n    _floatLabel(shouldAnimate = false) {\n        if (this._formField && this._formField.floatLabel === 'auto') {\n            if (shouldAnimate) {\n                this._formField._animateAndLockLabel();\n            }\n            else {\n                this._formField.floatLabel = 'always';\n            }\n            this._manuallyFloatingLabel = true;\n        }\n    }\n    /** If the label has been manually elevated, return it to its normal state. */\n    _resetLabel() {\n        if (this._manuallyFloatingLabel) {\n            if (this._formField) {\n                this._formField.floatLabel = 'auto';\n            }\n            this._manuallyFloatingLabel = false;\n        }\n    }\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    _subscribeToClosingActions() {\n        const firstStable = this._zone.onStable.pipe(take(1));\n        const optionChanges = this.autocomplete.options.changes.pipe(tap(() => this._positionStrategy.reapplyLastPosition()), \n        // Defer emitting to the stream until the next tick, because changing\n        // bindings in here will cause \"changed after checked\" errors.\n        delay(0));\n        // When the zone is stable initially, and when the option list changes...\n        return (merge(firstStable, optionChanges)\n            .pipe(\n        // create a new stream of panelClosingActions, replacing any previous streams\n        // that were created, and flatten it so our stream only emits closing events...\n        switchMap(() => {\n            // The `NgZone.onStable` always emits outside of the Angular zone, thus we have to re-enter\n            // the Angular zone. This will lead to change detection being called outside of the Angular\n            // zone and the `autocomplete.opened` will also emit outside of the Angular.\n            this._zone.run(() => {\n                const wasOpen = this.panelOpen;\n                this._resetActiveItem();\n                this.autocomplete._setVisibility();\n                this._changeDetectorRef.detectChanges();\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                }\n                if (wasOpen !== this.panelOpen) {\n                    // If the `panelOpen` state changed, we need to make sure to emit the `opened` or\n                    // `closed` event, because we may not have emitted it. This can happen\n                    // - if the users opens the panel and there are no options, but the\n                    //   options come in slightly later or as a result of the value changing,\n                    // - if the panel is closed after the user entered a string that did not match any\n                    //   of the available options,\n                    // - if a valid string is entered after an invalid one.\n                    if (this.panelOpen) {\n                        this.autocomplete.opened.emit();\n                    }\n                    else {\n                        this.autocomplete.closed.emit();\n                    }\n                }\n            });\n            return this.panelClosingActions;\n        }), \n        // when the first closing event occurs...\n        take(1))\n            // set the value, close the panel, and complete.\n            .subscribe(event => this._setValueAndClose(event)));\n    }\n    /** Destroys the autocomplete suggestion panel. */\n    _destroyPanel() {\n        if (this._overlayRef) {\n            this.closePanel();\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n    }\n    _assignOptionValue(value) {\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith\n            ? this.autocomplete.displayWith(value)\n            : value;\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        this._updateNativeInputValue(toDisplay != null ? toDisplay : '');\n    }\n    _updateNativeInputValue(value) {\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this._formField) {\n            this._formField._control.value = value;\n        }\n        else {\n            this._element.nativeElement.value = value;\n        }\n        this._previousValue = value;\n    }\n    /**\n     * This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    _setValueAndClose(event) {\n        const toSelect = event ? event.source : this._pendingAutoselectedOption;\n        if (toSelect) {\n            this._clearPreviousSelectedOption(toSelect);\n            this._assignOptionValue(toSelect.value);\n            this._onChange(toSelect.value);\n            this.autocomplete._emitSelectEvent(toSelect);\n            this._element.nativeElement.focus();\n        }\n        this.closePanel();\n    }\n    /**\n     * Clear any previous selected option and emit a selection change event for this option\n     */\n    _clearPreviousSelectedOption(skip) {\n        this.autocomplete.options.forEach(option => {\n            if (option !== skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n    _attachOverlay() {\n        if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatAutocompleteMissingPanelError();\n        }\n        let overlayRef = this._overlayRef;\n        if (!overlayRef) {\n            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, {\n                id: this._formField?.getLabelId(),\n            });\n            overlayRef = this._overlay.create(this._getOverlayConfig());\n            this._overlayRef = overlayRef;\n            this._handleOverlayEvents(overlayRef);\n            this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n                if (this.panelOpen && overlayRef) {\n                    overlayRef.updateSize({ width: this._getPanelWidth() });\n                }\n            });\n        }\n        else {\n            // Update the trigger, panel width and direction, in case anything has changed.\n            this._positionStrategy.setOrigin(this._getConnectedElement());\n            overlayRef.updateSize({ width: this._getPanelWidth() });\n        }\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this._portal);\n            this._closingActionsSubscription = this._subscribeToClosingActions();\n        }\n        const wasOpen = this.panelOpen;\n        this.autocomplete._setVisibility();\n        this.autocomplete._isOpen = this._overlayAttached = true;\n        this.autocomplete._setColor(this._formField?.color);\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n    _getOverlayConfig() {\n        return new OverlayConfig({\n            positionStrategy: this._getOverlayPosition(),\n            scrollStrategy: this._scrollStrategy(),\n            width: this._getPanelWidth(),\n            direction: this._dir ?? undefined,\n            panelClass: this._defaults?.overlayPanelClass,\n        });\n    }\n    _getOverlayPosition() {\n        const strategy = this._overlay\n            .position()\n            .flexibleConnectedTo(this._getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false);\n        this._setStrategyPositions(strategy);\n        this._positionStrategy = strategy;\n        return strategy;\n    }\n    /** Sets the positions on a position strategy based on the directive's input state. */\n    _setStrategyPositions(positionStrategy) {\n        // Note that we provide horizontal fallback positions, even though by default the dropdown\n        // width matches the input, because consumers can override the width. See #18854.\n        const belowPositions = [\n            { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n            { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' },\n        ];\n        // The overlay edge connected to the trigger should have squared corners, while\n        // the opposite end has rounded corners. We apply a CSS class to swap the\n        // border-radius based on the overlay position.\n        const panelClass = this._aboveClass;\n        const abovePositions = [\n            { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass },\n            { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass },\n        ];\n        let positions;\n        if (this.position === 'above') {\n            positions = abovePositions;\n        }\n        else if (this.position === 'below') {\n            positions = belowPositions;\n        }\n        else {\n            positions = [...belowPositions, ...abovePositions];\n        }\n        positionStrategy.withPositions(positions);\n    }\n    _getConnectedElement() {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n    }\n    _getPanelWidth() {\n        return this.autocomplete.panelWidth || this._getHostWidth();\n    }\n    /** Returns the width of the input element, so the panel width can match it. */\n    _getHostWidth() {\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n    /**\n     * Reset the active item to -1. This is so that pressing arrow keys will activate the correct\n     * option.\n     *\n     * If the consumer opted-in to automatically activatating the first option, activate the first\n     * *enabled* option.\n     */\n    _resetActiveItem() {\n        const autocomplete = this.autocomplete;\n        if (autocomplete.autoActiveFirstOption) {\n            // Find the index of the first *enabled* option. Avoid calling `_keyManager.setActiveItem`\n            // because it activates the first option that passes the skip predicate, rather than the\n            // first *enabled* option.\n            let firstEnabledOptionIndex = -1;\n            for (let index = 0; index < autocomplete.options.length; index++) {\n                const option = autocomplete.options.get(index);\n                if (!option.disabled) {\n                    firstEnabledOptionIndex = index;\n                    break;\n                }\n            }\n            autocomplete._keyManager.setActiveItem(firstEnabledOptionIndex);\n        }\n        else {\n            autocomplete._keyManager.setActiveItem(-1);\n        }\n    }\n    /** Determines whether the panel can be opened. */\n    _canOpen() {\n        const element = this._element.nativeElement;\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document?.defaultView || window;\n    }\n    /** Scrolls to a particular option in the list. */\n    _scrollToOption(index) {\n        // Given that we are not actually focusing active options, we must manually adjust scroll\n        // to reveal options below the fold. First, we find the offset of the option from the top\n        // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n        // the panel height + the option height, so the active option will be just visible at the\n        // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n        // will become the offset. If that offset is visible within the panel already, the scrollTop is\n        // not adjusted.\n        const autocomplete = this.autocomplete;\n        const labelCount = _countGroupLabelsBeforeOption(index, autocomplete.options, autocomplete.optionGroups);\n        if (index === 0 && labelCount === 1) {\n            // If we've got one group label before the option and we're at the top option,\n            // scroll the list to the top. This is better UX than scrolling the list to the\n            // top of the option, because it allows the user to read the top group's label.\n            autocomplete._setScrollTop(0);\n        }\n        else if (autocomplete.panel) {\n            const option = autocomplete.options.toArray()[index];\n            if (option) {\n                const element = option._getHostElement();\n                const newScrollPosition = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);\n                autocomplete._setScrollTop(newScrollPosition);\n            }\n        }\n    }\n    /** Handles keyboard events coming from the overlay panel. */\n    _handleOverlayEvents(overlayRef) {\n        // Use the `keydownEvents` in order to take advantage of\n        // the overlay event targeting provided by the CDK overlay.\n        overlayRef.keydownEvents().subscribe(event => {\n            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n            if ((event.keyCode === ESCAPE && !hasModifierKey(event)) ||\n                (event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey'))) {\n                // If the user had typed something in before we autoselected an option, and they decided\n                // to cancel the selection, restore the input value to the one they had typed in.\n                if (this._pendingAutoselectedOption) {\n                    this._updateNativeInputValue(this._valueBeforeAutoSelection ?? '');\n                    this._pendingAutoselectedOption = null;\n                }\n                this._closeKeyEventStream.next();\n                this._resetActiveItem();\n                // We need to stop propagation, otherwise the event will eventually\n                // reach the input itself and cause the overlay to be reopened.\n                event.stopPropagation();\n                event.preventDefault();\n            }\n        });\n        // Subscribe to the pointer events stream so that it doesn't get picked up by other overlays.\n        // TODO(crisbeto): we should switch `_getOutsideClickStream` eventually to use this stream,\n        // but the behvior isn't exactly the same and it ends up breaking some internal tests.\n        overlayRef.outsidePointerEvents().subscribe();\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteTriggerBase, deps: [{ token: i0.ElementRef }, { token: i1$1.Overlay }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: MAT_AUTOCOMPLETE_SCROLL_STRATEGY }, { token: i2$1.Directionality, optional: true }, { token: MAT_FORM_FIELD, host: true, optional: true }, { token: DOCUMENT, optional: true }, { token: i3.ViewportRuler }, { token: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: _MatAutocompleteTriggerBase, inputs: { autocomplete: [\"matAutocomplete\", \"autocomplete\"], position: [\"matAutocompletePosition\", \"position\"], connectedTo: [\"matAutocompleteConnectedTo\", \"connectedTo\"], autocompleteAttribute: [\"autocomplete\", \"autocompleteAttribute\"], autocompleteDisabled: [\"matAutocompleteDisabled\", \"autocompleteDisabled\"] }, usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: _MatAutocompleteTriggerBase, decorators: [{\n            type: Directive\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1$1.Overlay }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY]\n                }] }, { type: i2$1.Directionality, decorators: [{\n                    type: Optional\n                }] }, { type: i4.MatFormField, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_FORM_FIELD]\n                }, {\n                    type: Host\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [DOCUMENT]\n                }] }, { type: i3.ViewportRuler }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\n                }] }]; }, propDecorators: { autocomplete: [{\n                type: Input,\n                args: ['matAutocomplete']\n            }], position: [{\n                type: Input,\n                args: ['matAutocompletePosition']\n            }], connectedTo: [{\n                type: Input,\n                args: ['matAutocompleteConnectedTo']\n            }], autocompleteAttribute: [{\n                type: Input,\n                args: ['autocomplete']\n            }], autocompleteDisabled: [{\n                type: Input,\n                args: ['matAutocompleteDisabled']\n            }] } });\nclass MatAutocompleteTrigger extends _MatAutocompleteTriggerBase {\n    constructor() {\n        super(...arguments);\n        this._aboveClass = 'mat-mdc-autocomplete-panel-above';\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteTrigger, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: MatAutocompleteTrigger, selector: \"input[matAutocomplete], textarea[matAutocomplete]\", host: { listeners: { \"focusin\": \"_handleFocus()\", \"blur\": \"_onTouched()\", \"input\": \"_handleInput($event)\", \"keydown\": \"_handleKeydown($event)\", \"click\": \"_handleClick()\" }, properties: { \"attr.autocomplete\": \"autocompleteAttribute\", \"attr.role\": \"autocompleteDisabled ? null : \\\"combobox\\\"\", \"attr.aria-autocomplete\": \"autocompleteDisabled ? null : \\\"list\\\"\", \"attr.aria-activedescendant\": \"(panelOpen && activeOption) ? activeOption.id : null\", \"attr.aria-expanded\": \"autocompleteDisabled ? null : panelOpen.toString()\", \"attr.aria-owns\": \"(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id\", \"attr.aria-haspopup\": \"autocompleteDisabled ? null : \\\"listbox\\\"\" }, classAttribute: \"mat-mdc-autocomplete-trigger\" }, providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR], exportAs: [\"matAutocompleteTrigger\"], usesInheritance: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteTrigger, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `input[matAutocomplete], textarea[matAutocomplete]`,\n                    host: {\n                        'class': 'mat-mdc-autocomplete-trigger',\n                        '[attr.autocomplete]': 'autocompleteAttribute',\n                        '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                        '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                        '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                        '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                        '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                        '[attr.aria-haspopup]': 'autocompleteDisabled ? null : \"listbox\"',\n                        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                        // a little earlier. This avoids issues where IE delays the focusing of the input.\n                        '(focusin)': '_handleFocus()',\n                        '(blur)': '_onTouched()',\n                        '(input)': '_handleInput($event)',\n                        '(keydown)': '_handleKeydown($event)',\n                        '(click)': '_handleClick()',\n                    },\n                    exportAs: 'matAutocompleteTrigger',\n                    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR],\n                }]\n        }] });\n\nclass MatAutocompleteModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin], imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule], exports: [CdkScrollableModule,\n            MatAutocomplete,\n            MatOptionModule,\n            MatCommonModule,\n            MatAutocompleteTrigger,\n            MatAutocompleteOrigin] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule, CdkScrollableModule,\n            MatOptionModule,\n            MatCommonModule] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: MatAutocompleteModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [OverlayModule, MatOptionModule, MatCommonModule, CommonModule],\n                    exports: [\n                        CdkScrollableModule,\n                        MatAutocomplete,\n                        MatOptionModule,\n                        MatCommonModule,\n                        MatAutocompleteTrigger,\n                        MatAutocompleteOrigin,\n                    ],\n                    declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n                    providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocomplete, MatAutocompleteModule, MatAutocompleteOrigin, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, _MatAutocompleteBase, _MatAutocompleteOriginBase, _MatAutocompleteTriggerBase, getMatAutocompleteMissingPanelError };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]}