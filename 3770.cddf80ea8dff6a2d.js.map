{"version":3,"file":"3770.cddf80ea8dff6a2d.js","mappings":"0sBAmWA,IA4DMA,GAAe,eAAfA,GAAeC,OAAA,SAAAD,KAAAE,OAAAC,KAAAH,EAAA,GAAfA,SACYI,UAAI,SAAAC,GAAA,WAAAA,GAAwFL,EAAe,EADvHA,EAEYM,UA7BkFC,6BAAE,CAAAC,KA6BSR,IAFzGA,EAGYS,UA9BkFF,6BAAE,IA2BhGP,CAAe,IChXsE,SAAAU,GAAAC,EAAAC,GAAA,KAAAD,EAAA,KAAAE,EAqHSN,0DAAE,8BAAFA,uBAAE,yBAAAO,GAAFP,0BAAEM,GAAA,IAAAE,EAAFR,4BAAE,OAAFA,wBAW/CQ,EAAAC,cAAAC,KAAAH,GAA0B,EAXqBP,CAWpB,2BAAAO,GAXoBP,0BAAEM,GAAA,IAAAK,EAAFX,4BAAE,OAAFA,wBAY7CW,EAAAC,gBAAAF,KAAAH,GAA4B,GAZiBP,0BAAE,CAajE,KAAAI,EAAA,KAAAS,EAb+Db,mDAAE,gBAAAa,EAAAC,cAAFd,CAOjC,SAAAa,EAAAE,OAPiCf,CAOjC,WAAAa,EAAAG,SAPiChB,CAOjC,gBAAAa,EAAAI,cAAA,WAAAC,GAAAd,EAAAC,GAAA,KAAAD,EAAA,KAAAe,EAPiCnB,0DAAE,4BAAFA,uBAAE,yBAAAO,GAAFP,0BAAEmB,GAAA,IAAAC,EAAFpB,4BAAE,OAAFA,wBAkBjDoB,EAAAX,cAAAC,KAAAH,GAA0B,EAlBuBP,CAkBtB,2BAAAO,GAlBsBP,0BAAEmB,GAAA,IAAAE,EAAFrB,4BAAE,OAAFA,wBAmB/CqB,EAAAT,gBAAAF,KAAAH,GAA4B,GAnBmBP,0BAAE,CAoBnE,KAAAI,EAAA,KAAAkB,EApBiEtB,mDAAE,SAAAsB,EAAAP,OAAFf,CAejD,WAAAsB,EAAAN,SAfiDhB,CAejD,gBAAAsB,EAAAL,cAAA,EAlInD,IAAMM,EAAqC,CACvCC,QAASC,aACTC,KAAM,IACFC,cAAW,kBAAMC,CAA0B,GAC3C,CAAC,IAAIC,WAAYC,mBACjBC,oBACA,CAAC,IAAIC,SAAOC,cAEhBC,WAAYC,GAEVC,MAAkCC,aAAA,GAAQd,GAAkC,IAAEC,QAASc,eAC7F,SAASH,EAA0BI,EAAWC,EAAgBC,EAAmBC,GAK7E,IAAMC,EAAa,IAAIC,aAAWF,EAASG,cAAc,2BACnDC,EAAU,IAAIrB,aAAWe,EAAgBC,EAAmBE,GAClE,OAAO,IAAII,MAAMD,EAAS,CACtBE,IAAK,SAACC,EAAQC,GAAQ,OAAKC,QAAQH,IAAIT,EAAUO,SAAWG,EAAQC,EAAS,EAC7EE,IAAK,SAACH,EAAQC,EAAUG,GAAK,OAAKF,QAAQC,IAAIb,EAAUO,SAAWG,EAAQC,EAAUG,EAAM,GAEnG,CACA,IAOMzB,EAA0B,eAA1BA,EAA0B,WAC5B,SAAAA,KAAcjC,OAAAC,KAAAgC,GAEVhC,KAAKa,cAAgB,IAAI6C,eACzB1D,KAAKgB,gBAAkB,IAAI0C,eAC3B1D,KAAK2D,kBAAoB,IAAID,eAC7B1D,KAAK4D,YAAa,EAClB5D,KAAK6D,UAAY,EACrB,CAAC/D,cAAAkC,EAAA,EAAA8B,IAAA,UAAAV,IACD,WACI,OAAOpD,KAAK+D,aAAe/D,KAAK+D,YAAYC,KAChD,GACA,CAAAF,IAAA,kBAAAL,MAEA,WAAkB,IAAAQ,EAAAjE,KACdA,KAAKkE,QACLlE,KAAK+D,YAAYI,QAAQC,UAAU,kBAAMH,EAAKC,OAAO,GAErDlE,KAAKgB,gBAAgBoD,UAAU,SAACC,GAAC,OAAKJ,EAAKK,kBAAoBD,EAAEhD,aAAa,GAC9ErB,KAAKuE,gBAELC,WAAW,kBAAMP,EAAKf,QAAQ7B,cAAgB4C,EAAK5C,aAAa,EAAE,IACtE,GAAC,CAAAyC,IAAA,qBAAAL,MACD,WACI,GAAIzD,KAAK4D,WAAY,CACjB5D,KAAK4D,YAAa,EAClB,IAAAa,EAAoDzE,KAAKkD,QAApCwB,EAAWD,EAAXC,YAAarD,EAAaoD,EAAbpD,cAAfoD,EAAXE,YACIC,cAAcC,QAC1BH,EAAYI,cAAczD,EAAa,CAE/C,GAAC,CAAAyC,IAAA,eAAAV,IACD,WACI,MAA4B,eAArBpD,KAAK+E,WAChB,GAAC,CAAAjB,IAAA,aAAAV,IACD,WACI,MAA4B,aAArBpD,KAAK+E,WAChB,GAAC,CAAAjB,IAAA,OAAAL,MACD,WACIzD,KAAKkD,QAAQ8B,MACjB,GAAC,CAAAlB,IAAA,WAAAL,MACD,WACIzD,KAAKkD,QAAQ+B,UACjB,GACA,CAAAnB,IAAA,kBAAAL,MAMA,SAAgByB,EAAMC,GACdnF,KAAK6D,UAAUuB,OAAS,IACxBpF,KAAK6D,UAAUqB,EAAO,GAAGG,MAAMC,cAAgBH,EAAU,GAAK,OAEtE,GACA,CAAArB,IAAA,gBAAAL,MAGA,WACIzD,KAAK6D,UAAY,GACjB,IAAI0B,EAAY,EACZrC,EAAUJ,SAAS0C,cAAc,yBAChCtC,IACDqC,EAAY,EACZrC,EAAUJ,SAAS0C,cAAc,6CAErC,QAASC,EAAI,EAAGA,EAAIvC,EAAQwC,SAASN,OAAQK,GAAKF,EAC9CvF,KAAK6D,UAAU8B,KAAKzC,EAAQwC,SAASD,GAE7C,GAAC,CAAA3B,IAAA,QAAAL,MACD,WAAQ,IAAAmC,EAAA5F,KAEJwE,WAAW,kBAAMoB,EAAKrB,eAAe,EAAE,KACvC,IAAQrB,EAA+DlD,KAA/DkD,QAAyCoB,EAAsBtE,KAAtBsE,kBACjDpB,EAAQ2C,MAAM3B,MADyDlE,KAAtD6F,MACSC,WAC1B5C,EAAQ2C,MAAME,kBACVzB,IACApB,EAAQ7B,cAAgBiD,EAExBE,WAAW,kBAAMoB,EAAKjC,kBAAkB7C,KAAK8E,EAAKb,YAAY,EAAE,KAMxE,KAAC/C,CAAA,CApF2B,GAA1BA,SAqFY/B,UAAI,SAAAC,GAAA,WAAAA,GAAwF8B,EAA0B,EArFlIA,EAsFYgE,UADkF5F,8BAAE,CAAAC,KACJ2B,EAA0BiE,UAAA,yBAAAC,eAAA,SAAA1F,EAAAC,EAAA0F,GAG5D,IAAAC,EAH4D,EAAA5F,GADxBJ,2BAAE+F,EAI7CE,UAAO,KAAA7F,GAJoCJ,2BAAEgG,EAAFhG,6BAAEK,EAAAoF,MAAAO,EAAA,EAAAE,UAAA,SAAA9F,EAAAC,GAIiC,IAAA2F,EAJjC,EAAA5F,GAAFJ,wBAIyByB,aAAU,KAAArB,GAJnCJ,2BAAEgG,EAAFhG,6BAAEK,EAAAsD,YAAAqC,EAAA,EAAAG,OAAA,CAAArF,cAAA,gBAAAC,OAAA,SAAA4D,YAAA,cAAA3D,SAAA,WAAAC,cAAA,iBAAAmF,QAAA,CAAA3F,cAAA,gBAAAG,gBAAA,kBAAA2C,kBAAA,qBAAA8C,SAAA,CAAFrG,+BAC8U,CACtauB,EACAa,MACHkE,MAAA,EAAAC,KAAA,EAAAC,OAAA,8XAAAC,SAAA,SAAArG,EAAAC,GAAA,EAAAD,IAJ2FJ,oCAAE,KAAFA,uBAAE,EAAAG,GAAA,gCAAFH,uBAAE,EAAAkB,GAAA,8BAAFlB,qCAqB7E,EAAAI,IArB6EJ,uBAAE,WAAAK,EAAAsE,aAAF3E,sBAAE,GAAFA,uBAAE,2BAc3C,EAAA0G,aAAA,CAOyBC,WAAwFA,eAAoGA,kBAAgFC,cAAaC,cAAA,EAAAC,gBAAA,IA1GvWlF,CAA0B,IAkK1BmF,GAAc,eAAdA,GAAcrH,OAAA,SAAAqH,KAAApH,OAAAC,KAAAmH,EAAA,GAAdA,SACYlH,UAAI,SAAAC,GAAA,WAAAA,GAAwFiH,EAAc,EADtHA,EAEYhH,UA/EkFC,6BAAE,CAAAC,KA+ES8G,IAFzGA,EA+CY7G,UA5HkFF,6BAAE,CAAAgH,QAAA,CA4HmCC,eAAcC,mBAAkBC,mBAAkBC,aAC/KF,mBACAG,iBACAC,gBACAC,iBACAC,8BACAC,iBACAC,uBACAC,wBACAC,wBACAC,sBACAC,0BACAC,uBACAZ,mBACAa,sBACAC,wBACAC,mBACAC,qBACAC,oBACAC,gBACAC,uBACAC,sBACAC,sBACAC,sBACAC,2BACAC,6BACAC,iCACAC,uBACAC,kBACAC,wBACAC,mBACAC,wBACAC,6BACAC,2BACAC,iBACAC,wBACAC,uBACAC,oBACAC,0BACAC,iBACAC,eACAjK,kBACAkK,MAzFN5C,CAAc","names":["ScrollingModule","_createClass","_classCallCheck","this","ɵfac","t","ɵmod","i0","type","ɵinj","ResponsiveStepperComponent_mat_horizontal_stepper_1_Template","rf","ctx","_r3","$event","ctx_r2","animationDone","emit","ctx_r4","selectionChange","ctx_r0","labelPosition","linear","selected","selectedIndex","ResponsiveStepperComponent_mat_vertical_stepper_2_Template","_r6","ctx_r5","ctx_r7","ctx_r1","MAT_STEPPER_PROXY_FACTORY_PROVIDER","provide","MatStepper","deps","forwardRef","ResponsiveStepperComponent","Optional","Directionality","ChangeDetectorRef","Inject","DOCUMENT","useFactory","MAT_STEPPER_PROXY_FACTORY","CDK_STEPPER_PROXY_FACTORY_PROVIDER","_objectSpread","CdkStepper","component","directionality","changeDetectorRef","document","elementRef","ElementRef","createElement","stepper","Proxy","get","target","property","Reflect","set","value","EventEmitter","orientationChange","needsFocus","htmlSteps","key","stepperList","first","_this","reset","changes","subscribe","e","lastSelectedIndex","syncHTMLSteps","setTimeout","_this$stepper","_keyManager","_elementRef","nativeElement","focus","setActiveItem","orientation","next","previous","step","enabled","length","style","pointerEvents","increment","querySelector","i","children","push","_this2","steps","toArray","notifyOnChanges","ɵcmp","selectors","contentQueries","dirIndex","_t","MatStep","viewQuery","inputs","outputs","features","decls","vars","consts","template","dependencies","i1","i2","encapsulation","changeDetection","MaterialModule","imports","CommonModule","CdkStepperModule","MatStepperModule","A11yModule","CdkTableModule","CdkTreeModule","DragDropModule","MatLegacyAutocompleteModule","MatBadgeModule","MatBottomSheetModule","MatLegacyButtonModule","MatButtonToggleModule","MatLegacyCardModule","MatLegacyCheckboxModule","MatLegacyChipsModule","MatDatepickerModule","MatLegacyDialogModule","MatDividerModule","MatExpansionModule","MatGridListModule","MatIconModule","MatLegacyInputModule","MatLegacyListModule","MatLegacyMenuModule","MatNativeDateModule","MatLegacyPaginatorModule","MatLegacyProgressBarModule","MatLegacyProgressSpinnerModule","MatLegacyRadioModule","MatRippleModule","MatLegacySelectModule","MatSidenavModule","MatLegacySliderModule","MatLegacySlideToggleModule","MatLegacySnackBarModule","MatSortModule","MatLegacyTableModule","MatLegacyTabsModule","MatToolbarModule","MatLegacyTooltipModule","MatTreeModule","PortalModule","ScrollingModule$1"],"sourceRoot":"webpack:///","sources":["./node_modules/@angular/cdk-experimental/fesm2022/scrolling.mjs","./node_modules/@rollthecloudinc/material/fesm2022/rollthecloudinc-material.mjs"],"sourcesContent":["import { coerceNumberProperty } from '@angular/cdk/coercion';\nimport { VIRTUAL_SCROLL_STRATEGY } from '@angular/cdk/scrolling';\nimport * as i0 from '@angular/core';\nimport { forwardRef, Directive, Input, NgModule } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n/**\n * A class that tracks the size of items that have been seen and uses it to estimate the average\n * item size.\n */\nclass ItemSizeAverager {\n    /** @param defaultItemSize The default size to use for items when no data is available. */\n    constructor(defaultItemSize = 50) {\n        /** The total amount of weight behind the current average. */\n        this._totalWeight = 0;\n        this._defaultItemSize = defaultItemSize;\n        this._averageItemSize = defaultItemSize;\n    }\n    /** Returns the average item size. */\n    getAverageItemSize() {\n        return this._averageItemSize;\n    }\n    /**\n     * Adds a measurement sample for the estimator to consider.\n     * @param range The measured range.\n     * @param size The measured size of the given range in pixels.\n     */\n    addSample(range, size) {\n        const newTotalWeight = this._totalWeight + range.end - range.start;\n        if (newTotalWeight) {\n            const newAverageItemSize = (size + this._averageItemSize * this._totalWeight) / newTotalWeight;\n            if (newAverageItemSize) {\n                this._averageItemSize = newAverageItemSize;\n                this._totalWeight = newTotalWeight;\n            }\n        }\n    }\n    /** Resets the averager. */\n    reset() {\n        this._averageItemSize = this._defaultItemSize;\n        this._totalWeight = 0;\n    }\n}\n/** Virtual scrolling strategy for lists with items of unknown or dynamic size. */\nclass AutoSizeVirtualScrollStrategy {\n    /**\n     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n     *     If the amount of buffer dips below this number, more items will be rendered.\n     * @param maxBufferPx The number of pixels worth of buffer to shoot for when rendering new items.\n     *     If the actual amount turns out to be less it will not necessarily trigger an additional\n     *     rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n     * @param averager The averager used to estimate the size of unseen items.\n     */\n    constructor(minBufferPx, maxBufferPx, averager = new ItemSizeAverager()) {\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = new Observable(() => {\n            // TODO(mmalerba): Implement.\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                throw Error('cdk-virtual-scroll: scrolledIndexChange is currently not supported for the' +\n                    ' autosize scroll strategy');\n            }\n        });\n        /** The attached viewport. */\n        this._viewport = null;\n        /**\n         * The number of consecutive cycles where removing extra items has failed. Failure here means that\n         * we estimated how many items we could safely remove, but our estimate turned out to be too much\n         * and it wasn't safe to remove that many elements.\n         */\n        this._removalFailures = 0;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._averager = averager;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._averager.reset();\n        this._viewport = viewport;\n        this._renderContentForCurrentOffset();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._viewport = null;\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        if (this._viewport) {\n            this._updateRenderedContentAfterScroll();\n        }\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        if (this._viewport) {\n            this._renderContentForCurrentOffset();\n            this._checkRenderedContentSize();\n        }\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() {\n        if (this._viewport) {\n            this._checkRenderedContentSize();\n        }\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() {\n        if (this._viewport) {\n            this._checkRenderedContentOffset();\n        }\n    }\n    /** Scroll to the offset for the given index. */\n    scrollToIndex() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // TODO(mmalerba): Implement.\n            throw Error('cdk-virtual-scroll: scrollToIndex is currently not supported for the autosize' +\n                ' scroll strategy');\n        }\n    }\n    /**\n     * Update the buffer parameters.\n     * @param minBufferPx The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * @param maxBufferPx The number of buffer items to render beyond the edge of the viewport (in\n     *     pixels).\n     */\n    updateBufferSize(minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /** Update the rendered content after the user scrolls. */\n    _updateRenderedContentAfterScroll() {\n        const viewport = this._viewport;\n        // The current scroll offset.\n        const scrollOffset = viewport.measureScrollOffset();\n        // The delta between the current scroll offset and the previously recorded scroll offset.\n        let scrollDelta = scrollOffset - this._lastScrollOffset;\n        // The magnitude of the scroll delta.\n        let scrollMagnitude = Math.abs(scrollDelta);\n        // The currently rendered range.\n        const renderedRange = viewport.getRenderedRange();\n        // If we're scrolling toward the top, we need to account for the fact that the predicted amount\n        // of content and the actual amount of scrollable space may differ. We address this by slowly\n        // correcting the difference on each scroll event.\n        let offsetCorrection = 0;\n        if (scrollDelta < 0) {\n            // The content offset we would expect based on the average item size.\n            const predictedOffset = renderedRange.start * this._averager.getAverageItemSize();\n            // The difference between the predicted size of the un-rendered content at the beginning and\n            // the actual available space to scroll over. We need to reduce this to zero by the time the\n            // user scrolls to the top.\n            // - 0 indicates that the predicted size and available space are the same.\n            // - A negative number that the predicted size is smaller than the available space.\n            // - A positive number indicates the predicted size is larger than the available space\n            const offsetDifference = predictedOffset - this._lastRenderedContentOffset;\n            // The amount of difference to correct during this scroll event. We calculate this as a\n            // percentage of the total difference based on the percentage of the distance toward the top\n            // that the user scrolled.\n            offsetCorrection = Math.round(offsetDifference *\n                Math.max(0, Math.min(1, scrollMagnitude / (scrollOffset + scrollMagnitude))));\n            // Based on the offset correction above, we pretend that the scroll delta was bigger or\n            // smaller than it actually was, this way we can start to eliminate the difference.\n            scrollDelta = scrollDelta - offsetCorrection;\n            scrollMagnitude = Math.abs(scrollDelta);\n        }\n        // The current amount of buffer past the start of the viewport.\n        const startBuffer = this._lastScrollOffset - this._lastRenderedContentOffset;\n        // The current amount of buffer past the end of the viewport.\n        const endBuffer = this._lastRenderedContentOffset +\n            this._lastRenderedContentSize -\n            (this._lastScrollOffset + viewport.getViewportSize());\n        // The amount of unfilled space that should be filled on the side the user is scrolling toward\n        // in order to safely absorb the scroll delta.\n        const underscan = scrollMagnitude + this._minBufferPx - (scrollDelta < 0 ? startBuffer : endBuffer);\n        // Check if there's unfilled space that we need to render new elements to fill.\n        if (underscan > 0) {\n            // Check if the scroll magnitude was larger than the viewport size. In this case the user\n            // won't notice a discontinuity if we just jump to the new estimated position in the list.\n            // However, if the scroll magnitude is smaller than the viewport the user might notice some\n            // jitteriness if we just jump to the estimated position. Instead we make sure to scroll by\n            // the same number of pixels as the scroll magnitude.\n            if (scrollMagnitude >= viewport.getViewportSize()) {\n                this._renderContentForCurrentOffset();\n            }\n            else {\n                // The number of new items to render on the side the user is scrolling towards. Rather than\n                // just filling the underscan space, we actually fill enough to have a buffer size of\n                // `maxBufferPx`. This gives us a little wiggle room in case our item size estimate is off.\n                const addItems = Math.max(0, Math.ceil((underscan - this._minBufferPx + this._maxBufferPx) /\n                    this._averager.getAverageItemSize()));\n                // The amount of filled space beyond what is necessary on the side the user is scrolling\n                // away from.\n                const overscan = (scrollDelta < 0 ? endBuffer : startBuffer) - this._minBufferPx + scrollMagnitude;\n                // The number of currently rendered items to remove on the side the user is scrolling away\n                // from. If removal has failed in recent cycles we are less aggressive in how much we try to\n                // remove.\n                const unboundedRemoveItems = Math.floor(overscan / this._averager.getAverageItemSize() / (this._removalFailures + 1));\n                const removeItems = Math.min(renderedRange.end - renderedRange.start, Math.max(0, unboundedRemoveItems));\n                // The new range we will tell the viewport to render. We first expand it to include the new\n                // items we want rendered, we then contract the opposite side to remove items we no longer\n                // want rendered.\n                const range = this._expandRange(renderedRange, scrollDelta < 0 ? addItems : 0, scrollDelta > 0 ? addItems : 0);\n                if (scrollDelta < 0) {\n                    range.end = Math.max(range.start + 1, range.end - removeItems);\n                }\n                else {\n                    range.start = Math.min(range.end - 1, range.start + removeItems);\n                }\n                // The new offset we want to set on the rendered content. To determine this we measure the\n                // number of pixels we removed and then adjust the offset to the start of the rendered\n                // content or to the end of the rendered content accordingly (whichever one doesn't require\n                // that the newly added items to be rendered to calculate.)\n                let contentOffset;\n                let contentOffsetTo;\n                if (scrollDelta < 0) {\n                    let removedSize = viewport.measureRangeSize({\n                        start: range.end,\n                        end: renderedRange.end,\n                    });\n                    // Check that we're not removing too much.\n                    if (removedSize <= overscan) {\n                        contentOffset =\n                            this._lastRenderedContentOffset + this._lastRenderedContentSize - removedSize;\n                        this._removalFailures = 0;\n                    }\n                    else {\n                        // If the removal is more than the overscan can absorb just undo it and record the fact\n                        // that the removal failed so we can be less aggressive next time.\n                        range.end = renderedRange.end;\n                        contentOffset = this._lastRenderedContentOffset + this._lastRenderedContentSize;\n                        this._removalFailures++;\n                    }\n                    contentOffsetTo = 'to-end';\n                }\n                else {\n                    const removedSize = viewport.measureRangeSize({\n                        start: renderedRange.start,\n                        end: range.start,\n                    });\n                    // Check that we're not removing too much.\n                    if (removedSize <= overscan) {\n                        contentOffset = this._lastRenderedContentOffset + removedSize;\n                        this._removalFailures = 0;\n                    }\n                    else {\n                        // If the removal is more than the overscan can absorb just undo it and record the fact\n                        // that the removal failed so we can be less aggressive next time.\n                        range.start = renderedRange.start;\n                        contentOffset = this._lastRenderedContentOffset;\n                        this._removalFailures++;\n                    }\n                    contentOffsetTo = 'to-start';\n                }\n                // Set the range and offset we calculated above.\n                viewport.setRenderedRange(range);\n                viewport.setRenderedContentOffset(contentOffset + offsetCorrection, contentOffsetTo);\n            }\n        }\n        else if (offsetCorrection) {\n            // Even if the rendered range didn't change, we may still need to adjust the content offset to\n            // simulate scrolling slightly slower or faster than the user actually scrolled.\n            viewport.setRenderedContentOffset(this._lastRenderedContentOffset + offsetCorrection);\n        }\n        // Save the scroll offset to be compared to the new value on the next scroll event.\n        this._lastScrollOffset = scrollOffset;\n    }\n    /**\n     * Checks the size of the currently rendered content and uses it to update the estimated item size\n     * and estimated total content size.\n     */\n    _checkRenderedContentSize() {\n        const viewport = this._viewport;\n        this._lastRenderedContentSize = viewport.measureRenderedContentSize();\n        this._averager.addSample(viewport.getRenderedRange(), this._lastRenderedContentSize);\n        this._updateTotalContentSize(this._lastRenderedContentSize);\n    }\n    /** Checks the currently rendered content offset and saves the value for later use. */\n    _checkRenderedContentOffset() {\n        const viewport = this._viewport;\n        this._lastRenderedContentOffset = viewport.getOffsetToRenderedContentStart();\n    }\n    /**\n     * Recalculates the rendered content based on our estimate of what should be shown at the current\n     * scroll offset.\n     */\n    _renderContentForCurrentOffset() {\n        const viewport = this._viewport;\n        const scrollOffset = viewport.measureScrollOffset();\n        this._lastScrollOffset = scrollOffset;\n        this._removalFailures = 0;\n        const itemSize = this._averager.getAverageItemSize();\n        const firstVisibleIndex = Math.min(viewport.getDataLength() - 1, Math.floor(scrollOffset / itemSize));\n        const bufferSize = Math.ceil(this._maxBufferPx / itemSize);\n        const range = this._expandRange(this._getVisibleRangeForIndex(firstVisibleIndex), bufferSize, bufferSize);\n        viewport.setRenderedRange(range);\n        viewport.setRenderedContentOffset(itemSize * range.start);\n    }\n    // TODO: maybe move to base class, can probably share with fixed size strategy.\n    /**\n     * Gets the visible range of data for the given start index. If the start index is too close to\n     * the end of the list it may be backed up to ensure the estimated size of the range is enough to\n     * fill the viewport.\n     * Note: must not be called if `this._viewport` is null\n     * @param startIndex The index to start the range at\n     * @return a range estimated to be large enough to fill the viewport when rendered.\n     */\n    _getVisibleRangeForIndex(startIndex) {\n        const viewport = this._viewport;\n        const range = {\n            start: startIndex,\n            end: startIndex + Math.ceil(viewport.getViewportSize() / this._averager.getAverageItemSize()),\n        };\n        const extra = range.end - viewport.getDataLength();\n        if (extra > 0) {\n            range.start = Math.max(0, range.start - extra);\n        }\n        return range;\n    }\n    // TODO: maybe move to base class, can probably share with fixed size strategy.\n    /**\n     * Expand the given range by the given amount in either direction.\n     * Note: must not be called if `this._viewport` is null\n     * @param range The range to expand\n     * @param expandStart The number of items to expand the start of the range by.\n     * @param expandEnd The number of items to expand the end of the range by.\n     * @return The expanded range.\n     */\n    _expandRange(range, expandStart, expandEnd) {\n        const viewport = this._viewport;\n        const start = Math.max(0, range.start - expandStart);\n        const end = Math.min(viewport.getDataLength(), range.end + expandEnd);\n        return { start, end };\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize(renderedContentSize) {\n        const viewport = this._viewport;\n        const renderedRange = viewport.getRenderedRange();\n        const totalSize = renderedContentSize +\n            (viewport.getDataLength() - (renderedRange.end - renderedRange.start)) *\n                this._averager.getAverageItemSize();\n        viewport.setTotalContentSize(totalSize);\n    }\n}\n/**\n * Provider factory for `AutoSizeVirtualScrollStrategy` that simply extracts the already created\n * `AutoSizeVirtualScrollStrategy` from the given directive.\n * @param autoSizeDir The instance of `CdkAutoSizeVirtualScroll` to extract the\n *     `AutoSizeVirtualScrollStrategy` from.\n */\nfunction _autoSizeVirtualScrollStrategyFactory(autoSizeDir) {\n    return autoSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports unknown or dynamic size items. */\nclass CdkAutoSizeVirtualScroll {\n    constructor() {\n        this._minBufferPx = 100;\n        this._maxBufferPx = 200;\n        /** The scroll strategy used by this directive. */\n        this._scrollStrategy = new AutoSizeVirtualScrollStrategy(this.minBufferPx, this.maxBufferPx);\n    }\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx() {\n        return this._minBufferPx;\n    }\n    set minBufferPx(value) {\n        this._minBufferPx = coerceNumberProperty(value);\n    }\n    /**\n     * The number of pixels worth of buffer to shoot for when rendering new items.\n     * If the actual amount turns out to be less it will not necessarily trigger an additional\n     * rendering cycle (as long as the amount of buffer is still greater than `minBufferPx`).\n     * Defaults to 200px.\n     */\n    get maxBufferPx() {\n        return this._maxBufferPx;\n    }\n    set maxBufferPx(value) {\n        this._maxBufferPx = coerceNumberProperty(value);\n    }\n    ngOnChanges() {\n        this._scrollStrategy.updateBufferSize(this.minBufferPx, this.maxBufferPx);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: CdkAutoSizeVirtualScroll, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"16.0.0\", type: CdkAutoSizeVirtualScroll, selector: \"cdk-virtual-scroll-viewport[autosize]\", inputs: { minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, providers: [\n            {\n                provide: VIRTUAL_SCROLL_STRATEGY,\n                useFactory: _autoSizeVirtualScrollStrategyFactory,\n                deps: [forwardRef(() => CdkAutoSizeVirtualScroll)],\n            },\n        ], usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: CdkAutoSizeVirtualScroll, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[autosize]',\n                    providers: [\n                        {\n                            provide: VIRTUAL_SCROLL_STRATEGY,\n                            useFactory: _autoSizeVirtualScrollStrategyFactory,\n                            deps: [forwardRef(() => CdkAutoSizeVirtualScroll)],\n                        },\n                    ],\n                }]\n        }], propDecorators: { minBufferPx: [{\n                type: Input\n            }], maxBufferPx: [{\n                type: Input\n            }] } });\n\nclass ScrollingModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: ScrollingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.0.0\", ngImport: i0, type: ScrollingModule, declarations: [CdkAutoSizeVirtualScroll], exports: [CdkAutoSizeVirtualScroll] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: ScrollingModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.0\", ngImport: i0, type: ScrollingModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [CdkAutoSizeVirtualScroll],\n                    declarations: [CdkAutoSizeVirtualScroll],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoSizeVirtualScrollStrategy, CdkAutoSizeVirtualScroll, ItemSizeAverager, ScrollingModule, _autoSizeVirtualScrollStrategyFactory };\n","import * as i1 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { forwardRef, Optional, ChangeDetectorRef, Inject, ElementRef, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, ViewChildren, ContentChildren, NgModule } from '@angular/core';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { DragDropModule } from '@angular/cdk/drag-drop';\nimport { PortalModule } from '@angular/cdk/portal';\nimport { ScrollingModule } from '@angular/cdk/scrolling';\nimport { CdkStepper, CdkStepperModule } from '@angular/cdk/stepper';\nimport { CdkTableModule } from '@angular/cdk/table';\nimport { CdkTreeModule } from '@angular/cdk/tree';\nimport { MatLegacyAutocompleteModule } from '@angular/material/legacy-autocomplete';\nimport { MatBadgeModule } from '@angular/material/badge';\nimport { MatBottomSheetModule } from '@angular/material/bottom-sheet';\nimport { MatLegacyButtonModule } from '@angular/material/legacy-button';\nimport { MatButtonToggleModule } from '@angular/material/button-toggle';\nimport { MatLegacyCardModule } from '@angular/material/legacy-card';\nimport { MatLegacyCheckboxModule } from '@angular/material/legacy-checkbox';\nimport { MatLegacyChipsModule } from '@angular/material/legacy-chips';\nimport * as i2 from '@angular/material/stepper';\nimport { MatStepper, MatStep, MatStepperModule } from '@angular/material/stepper';\nimport { MatDatepickerModule } from '@angular/material/datepicker';\nimport { MatLegacyDialogModule } from '@angular/material/legacy-dialog';\nimport { MatDividerModule } from '@angular/material/divider';\nimport { MatExpansionModule } from '@angular/material/expansion';\nimport { MatGridListModule } from '@angular/material/grid-list';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatLegacyInputModule } from '@angular/material/legacy-input';\nimport { MatLegacyListModule } from '@angular/material/legacy-list';\nimport { MatLegacyMenuModule } from '@angular/material/legacy-menu';\nimport { MatNativeDateModule, MatRippleModule } from '@angular/material/core';\nimport { MatLegacyPaginatorModule } from '@angular/material/legacy-paginator';\nimport { MatLegacyProgressBarModule } from '@angular/material/legacy-progress-bar';\nimport { MatLegacyProgressSpinnerModule } from '@angular/material/legacy-progress-spinner';\nimport { MatLegacyRadioModule } from '@angular/material/legacy-radio';\nimport { MatLegacySelectModule } from '@angular/material/legacy-select';\nimport { MatSidenavModule } from '@angular/material/sidenav';\nimport { MatLegacySliderModule } from '@angular/material/legacy-slider';\nimport { MatLegacySlideToggleModule } from '@angular/material/legacy-slide-toggle';\nimport { MatLegacySnackBarModule } from '@angular/material/legacy-snack-bar';\nimport { MatSortModule } from '@angular/material/sort';\nimport { MatLegacyTableModule } from '@angular/material/legacy-table';\nimport { MatLegacyTabsModule } from '@angular/material/legacy-tabs';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport { MatLegacyTooltipModule } from '@angular/material/legacy-tooltip';\nimport { MatTreeModule } from '@angular/material/tree';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { ScrollingModule as ScrollingModule$1 } from '@angular/cdk-experimental/scrolling';\n\nconst MAT_STEPPER_PROXY_FACTORY_PROVIDER = {\n    provide: MatStepper,\n    deps: [\n        forwardRef(() => ResponsiveStepperComponent),\n        [new Optional(), Directionality],\n        ChangeDetectorRef,\n        [new Inject(DOCUMENT)]\n    ],\n    useFactory: MAT_STEPPER_PROXY_FACTORY\n};\nconst CDK_STEPPER_PROXY_FACTORY_PROVIDER = { ...MAT_STEPPER_PROXY_FACTORY_PROVIDER, provide: CdkStepper };\nfunction MAT_STEPPER_PROXY_FACTORY(component, directionality, changeDetectorRef, document) {\n    // We create a fake stepper primarily so we can generate a proxy from it. The fake one, however, is used until\n    // our view is initialized. The reason we need a proxy is so we can toggle between our 2 steppers\n    // (vertical and horizontal) depending on  our \"orientation\" property. Probably a good idea to include a polyfill\n    // for the Proxy class: https://github.com/GoogleChrome/proxy-polyfill.\n    const elementRef = new ElementRef(document.createElement('mat-horizontal-stepper'));\n    const stepper = new MatStepper(directionality, changeDetectorRef, elementRef /*, document*/);\n    return new Proxy(stepper, {\n        get: (target, property) => Reflect.get(component.stepper || target, property),\n        set: (target, property, value) => Reflect.set(component.stepper || target, property, value)\n    });\n}\n/**\n * Configurable vertical/horizontal layout.<br>\n * Keeps input fields state.<br>\n * Allow to make headers un-clickable (disabled) with normal cursor: see updateStepState().\n *\n * Authors: @grant77, @davideas\n */\nclass ResponsiveStepperComponent {\n    constructor() {\n        // public events\n        this.animationDone = new EventEmitter();\n        this.selectionChange = new EventEmitter();\n        this.orientationChange = new EventEmitter();\n        this.needsFocus = false;\n        this.htmlSteps = [];\n    }\n    get stepper() {\n        return this.stepperList && this.stepperList.first;\n    }\n    /*constructor(private changeDetectorRef: ChangeDetectorRef) {\n    }*/\n    ngAfterViewInit() {\n        this.reset();\n        this.stepperList.changes.subscribe(() => this.reset());\n        // Emitted from (animationDone) event\n        this.selectionChange.subscribe((e) => this.lastSelectedIndex = e.selectedIndex);\n        this.syncHTMLSteps();\n        // Initial step selection with enter animation if initial step > 1\n        setTimeout(() => this.stepper.selectedIndex = this.selectedIndex, 400);\n    }\n    ngAfterViewChecked() {\n        if (this.needsFocus) {\n            this.needsFocus = false;\n            const { _elementRef, _keyManager, selectedIndex } = this.stepper;\n            _elementRef.nativeElement.focus();\n            _keyManager.setActiveItem(selectedIndex);\n        }\n    }\n    get isHorizontal() {\n        return this.orientation === 'horizontal';\n    }\n    get isVertical() {\n        return this.orientation === 'vertical';\n    }\n    next() {\n        this.stepper.next();\n    }\n    previous() {\n        this.stepper.previous();\n    }\n    /**\n     * Enable/Disable the click on the step header.\n     *\n     * @param step The step number\n     * @param enabled The new state\n     */\n    updateStepState(step, enabled) {\n        if (this.htmlSteps.length > 0) {\n            this.htmlSteps[step - 1].style.pointerEvents = enabled ? '' : 'none';\n        }\n    }\n    /**\n     * Sync from the dom the list of HTML elements for the steps.\n     */\n    syncHTMLSteps() {\n        this.htmlSteps = [];\n        let increment = 1;\n        let stepper = document.querySelector('.mat-stepper-vertical');\n        if (!stepper) {\n            increment = 2; // 2, because Angular adds 2 elements for each horizontal step\n            stepper = document.querySelector('.mat-horizontal-stepper-header-container');\n        }\n        for (let i = 0; i < stepper.children.length; i += increment) {\n            this.htmlSteps.push(stepper.children[i]);\n        }\n    }\n    reset() {\n        // Delay is necessary (Too early in AfterViewInit: HTMLElements not loaded)\n        setTimeout(() => this.syncHTMLSteps(), 100);\n        const { stepper, steps, /*, changeDetectorRef,*/ lastSelectedIndex } = this;\n        stepper.steps.reset(steps.toArray());\n        stepper.steps.notifyOnChanges();\n        if (lastSelectedIndex) {\n            stepper.selectedIndex = lastSelectedIndex;\n            // After htmlSteps have been synced\n            setTimeout(() => this.orientationChange.emit(this.orientation), 101);\n        }\n        /*Promise.resolve().then(() => {\n            this.needsFocus = true;\n            changeDetectorRef.markForCheck();\n        });*/\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.5\", ngImport: i0, type: ResponsiveStepperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"14.0.0\", version: \"16.0.5\", type: ResponsiveStepperComponent, selector: \"responsive-stepper\", inputs: { labelPosition: \"labelPosition\", linear: \"linear\", orientation: \"orientation\", selected: \"selected\", selectedIndex: \"selectedIndex\" }, outputs: { animationDone: \"animationDone\", selectionChange: \"selectionChange\", orientationChange: \"orientationChange\" }, providers: [\n            MAT_STEPPER_PROXY_FACTORY_PROVIDER,\n            CDK_STEPPER_PROXY_FACTORY_PROVIDER\n        ], queries: [{ propertyName: \"steps\", predicate: MatStep }], viewQueries: [{ propertyName: \"stepperList\", predicate: MatStepper, descendants: true }], ngImport: i0, template: `\n        <ng-container [ngSwitch]=\"orientation\">\n            <mat-horizontal-stepper *ngSwitchDefault\n                                    [labelPosition]=\"labelPosition\"\n                                    [linear]=\"linear\"\n                                    [selected]=\"selected\"\n                                    [selectedIndex]=\"selectedIndex\"\n                                    (animationDone)=\"animationDone.emit($event)\"\n                                    (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-horizontal-stepper>\n            <mat-vertical-stepper *ngSwitchCase=\"'vertical'\"\n                                  [linear]=\"linear\"\n                                  [selected]=\"selected\"\n                                  [selectedIndex]=\"selectedIndex\"\n                                  (animationDone)=\"animationDone.emit($event)\"\n                                  (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-vertical-stepper>\n        </ng-container>`, isInline: true, dependencies: [{ kind: \"directive\", type: i1.NgSwitch, selector: \"[ngSwitch]\", inputs: [\"ngSwitch\"] }, { kind: \"directive\", type: i1.NgSwitchCase, selector: \"[ngSwitchCase]\", inputs: [\"ngSwitchCase\"] }, { kind: \"directive\", type: i1.NgSwitchDefault, selector: \"[ngSwitchDefault]\" }, { kind: \"component\", type: i2.MatStepper, selector: \"mat-stepper, mat-vertical-stepper, mat-horizontal-stepper, [matStepper]\", inputs: [\"selectedIndex\", \"disableRipple\", \"color\", \"labelPosition\", \"headerPosition\", \"animationDuration\"], outputs: [\"animationDone\"], exportAs: [\"matStepper\", \"matVerticalStepper\", \"matHorizontalStepper\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.5\", ngImport: i0, type: ResponsiveStepperComponent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'responsive-stepper',\n                    // templateUrl: './stepper.component.html',\n                    // styleUrls: ['./stepper.component.scss'],\n                    changeDetection: ChangeDetectionStrategy.OnPush,\n                    providers: [\n                        MAT_STEPPER_PROXY_FACTORY_PROVIDER,\n                        CDK_STEPPER_PROXY_FACTORY_PROVIDER\n                    ],\n                    template: `\n        <ng-container [ngSwitch]=\"orientation\">\n            <mat-horizontal-stepper *ngSwitchDefault\n                                    [labelPosition]=\"labelPosition\"\n                                    [linear]=\"linear\"\n                                    [selected]=\"selected\"\n                                    [selectedIndex]=\"selectedIndex\"\n                                    (animationDone)=\"animationDone.emit($event)\"\n                                    (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-horizontal-stepper>\n            <mat-vertical-stepper *ngSwitchCase=\"'vertical'\"\n                                  [linear]=\"linear\"\n                                  [selected]=\"selected\"\n                                  [selectedIndex]=\"selectedIndex\"\n                                  (animationDone)=\"animationDone.emit($event)\"\n                                  (selectionChange)=\"selectionChange.emit($event)\">\n            </mat-vertical-stepper>\n        </ng-container>`\n                }]\n        }], propDecorators: { labelPosition: [{\n                type: Input\n            }], linear: [{\n                type: Input\n            }], orientation: [{\n                type: Input\n            }], selected: [{\n                type: Input\n            }], selectedIndex: [{\n                type: Input\n            }], animationDone: [{\n                type: Output\n            }], selectionChange: [{\n                type: Output\n            }], orientationChange: [{\n                type: Output\n            }], stepperList: [{\n                type: ViewChildren,\n                args: [MatStepper]\n            }], steps: [{\n                type: ContentChildren,\n                args: [MatStep]\n            }] } });\n\nclass MaterialModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"16.0.5\", ngImport: i0, type: MaterialModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"16.0.5\", ngImport: i0, type: MaterialModule, declarations: [ResponsiveStepperComponent], imports: [CommonModule, CdkStepperModule, MatStepperModule], exports: [A11yModule,\n            CdkStepperModule,\n            CdkTableModule,\n            CdkTreeModule,\n            DragDropModule,\n            MatLegacyAutocompleteModule,\n            MatBadgeModule,\n            MatBottomSheetModule,\n            MatLegacyButtonModule,\n            MatButtonToggleModule,\n            MatLegacyCardModule,\n            MatLegacyCheckboxModule,\n            MatLegacyChipsModule,\n            MatStepperModule,\n            MatDatepickerModule,\n            MatLegacyDialogModule,\n            MatDividerModule,\n            MatExpansionModule,\n            MatGridListModule,\n            MatIconModule,\n            MatLegacyInputModule,\n            MatLegacyListModule,\n            MatLegacyMenuModule,\n            MatNativeDateModule,\n            MatLegacyPaginatorModule,\n            MatLegacyProgressBarModule,\n            MatLegacyProgressSpinnerModule,\n            MatLegacyRadioModule,\n            MatRippleModule,\n            MatLegacySelectModule,\n            MatSidenavModule,\n            MatLegacySliderModule,\n            MatLegacySlideToggleModule,\n            MatLegacySnackBarModule,\n            MatSortModule,\n            MatLegacyTableModule,\n            MatLegacyTabsModule,\n            MatToolbarModule,\n            MatLegacyTooltipModule,\n            MatTreeModule,\n            PortalModule,\n            ScrollingModule,\n            ScrollingModule$1,\n            // MatFormFieldModule,\n            ResponsiveStepperComponent] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"16.0.5\", ngImport: i0, type: MaterialModule, imports: [CommonModule, CdkStepperModule, MatStepperModule, A11yModule,\n            CdkStepperModule,\n            CdkTableModule,\n            CdkTreeModule,\n            DragDropModule,\n            MatLegacyAutocompleteModule,\n            MatBadgeModule,\n            MatBottomSheetModule,\n            MatLegacyButtonModule,\n            MatButtonToggleModule,\n            MatLegacyCardModule,\n            MatLegacyCheckboxModule,\n            MatLegacyChipsModule,\n            MatStepperModule,\n            MatDatepickerModule,\n            MatLegacyDialogModule,\n            MatDividerModule,\n            MatExpansionModule,\n            MatGridListModule,\n            MatIconModule,\n            MatLegacyInputModule,\n            MatLegacyListModule,\n            MatLegacyMenuModule,\n            MatNativeDateModule,\n            MatLegacyPaginatorModule,\n            MatLegacyProgressBarModule,\n            MatLegacyProgressSpinnerModule,\n            MatLegacyRadioModule,\n            MatRippleModule,\n            MatLegacySelectModule,\n            MatSidenavModule,\n            MatLegacySliderModule,\n            MatLegacySlideToggleModule,\n            MatLegacySnackBarModule,\n            MatSortModule,\n            MatLegacyTableModule,\n            MatLegacyTabsModule,\n            MatToolbarModule,\n            MatLegacyTooltipModule,\n            MatTreeModule,\n            PortalModule,\n            ScrollingModule,\n            ScrollingModule$1] }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"16.0.5\", ngImport: i0, type: MaterialModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule, CdkStepperModule, MatStepperModule],\n                    exports: [\n                        A11yModule,\n                        CdkStepperModule,\n                        CdkTableModule,\n                        CdkTreeModule,\n                        DragDropModule,\n                        MatLegacyAutocompleteModule,\n                        MatBadgeModule,\n                        MatBottomSheetModule,\n                        MatLegacyButtonModule,\n                        MatButtonToggleModule,\n                        MatLegacyCardModule,\n                        MatLegacyCheckboxModule,\n                        MatLegacyChipsModule,\n                        MatStepperModule,\n                        MatDatepickerModule,\n                        MatLegacyDialogModule,\n                        MatDividerModule,\n                        MatExpansionModule,\n                        MatGridListModule,\n                        MatIconModule,\n                        MatLegacyInputModule,\n                        MatLegacyListModule,\n                        MatLegacyMenuModule,\n                        MatNativeDateModule,\n                        MatLegacyPaginatorModule,\n                        MatLegacyProgressBarModule,\n                        MatLegacyProgressSpinnerModule,\n                        MatLegacyRadioModule,\n                        MatRippleModule,\n                        MatLegacySelectModule,\n                        MatSidenavModule,\n                        MatLegacySliderModule,\n                        MatLegacySlideToggleModule,\n                        MatLegacySnackBarModule,\n                        MatSortModule,\n                        MatLegacyTableModule,\n                        MatLegacyTabsModule,\n                        MatToolbarModule,\n                        MatLegacyTooltipModule,\n                        MatTreeModule,\n                        PortalModule,\n                        ScrollingModule,\n                        ScrollingModule$1,\n                        // MatFormFieldModule,\n                        ResponsiveStepperComponent\n                    ],\n                    declarations: [ResponsiveStepperComponent]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MAT_STEPPER_PROXY_FACTORY, MaterialModule, ResponsiveStepperComponent };\n"],"x_google_ignoreList":[0,1]}